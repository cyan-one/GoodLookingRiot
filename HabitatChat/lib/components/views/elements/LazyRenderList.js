"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

/*
Copyright 2019 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class ItemRange {
  constructor(topCount, renderCount, bottomCount) {
    this.topCount = topCount;
    this.renderCount = renderCount;
    this.bottomCount = bottomCount;
  }

  contains(range) {
    // don't contain empty ranges
    // as it will prevent clearing the list
    // once it is scrolled far enough out of view
    if (!range.renderCount && this.renderCount) {
      return false;
    }

    return range.topCount >= this.topCount && range.topCount + range.renderCount <= this.topCount + this.renderCount;
  }

  expand(amount) {
    // don't expand ranges that won't render anything
    if (this.renderCount === 0) {
      return this;
    }

    const topGrow = Math.min(amount, this.topCount);
    const bottomGrow = Math.min(amount, this.bottomCount);
    return new ItemRange(this.topCount - topGrow, this.renderCount + topGrow + bottomGrow, this.bottomCount - bottomGrow);
  }

  totalSize() {
    return this.topCount + this.renderCount + this.bottomCount;
  }

}

class LazyRenderList extends _react.default.Component {
  constructor(props) {
    super(props);
    this.state = {};
  }

  static getDerivedStateFromProps(props, state) {
    const range = LazyRenderList.getVisibleRangeFromProps(props);
    const intersectRange = range.expand(props.overflowMargin);
    const renderRange = range.expand(props.overflowItems);
    const listHasChangedSize = !!state.renderRange && renderRange.totalSize() !== state.renderRange.totalSize(); // only update render Range if the list has shrunk/grown and we need to adjust padding OR
    // if the new range + overflowMargin isn't contained by the old anymore

    if (listHasChangedSize || !state.renderRange || !state.renderRange.contains(intersectRange)) {
      return {
        renderRange
      };
    }

    return null;
  }

  static getVisibleRangeFromProps(props) {
    const {
      items,
      itemHeight,
      scrollTop,
      height
    } = props;
    const length = items ? items.length : 0;
    const topCount = Math.min(Math.max(0, Math.floor(scrollTop / itemHeight)), length);
    const itemsAfterTop = length - topCount;
    const visibleItems = height !== 0 ? Math.ceil(height / itemHeight) : 0;
    const renderCount = Math.min(visibleItems, itemsAfterTop);
    const bottomCount = itemsAfterTop - renderCount;
    return new ItemRange(topCount, renderCount, bottomCount);
  }

  render() {
    const {
      itemHeight,
      items,
      renderItem
    } = this.props;
    const {
      renderRange
    } = this.state;
    const {
      topCount,
      renderCount,
      bottomCount
    } = renderRange;
    const paddingTop = topCount * itemHeight;
    const paddingBottom = bottomCount * itemHeight;
    const renderedItems = (items || []).slice(topCount, topCount + renderCount);
    const element = this.props.element || "div";
    const elementProps = {
      "style": {
        paddingTop: "".concat(paddingTop, "px"),
        paddingBottom: "".concat(paddingBottom, "px")
      },
      "className": this.props.className
    };
    return _react.default.createElement(element, elementProps, renderedItems.map(renderItem));
  }

}

exports.default = LazyRenderList;
LazyRenderList.defaultProps = {
  overflowItems: 20,
  overflowMargin: 5
};
LazyRenderList.propTypes = {
  // height in pixels of the component returned by `renderItem`
  itemHeight: _propTypes.default.number.isRequired,
  // function to turn an element of `items` into a react component
  renderItem: _propTypes.default.func.isRequired,
  // scrollTop of the viewport (minus the height of any content above this list like other `LazyRenderList`s)
  scrollTop: _propTypes.default.number.isRequired,
  // the height of the viewport this content is scrolled in
  height: _propTypes.default.number.isRequired,
  // all items for the list. These should not be react components, see `renderItem`.
  items: _propTypes.default.array,
  // the amount of items to scroll before causing a rerender,
  // should typically be less than `overflowItems` unless applying
  // margins in the parent component when using multiple LazyRenderList in one viewport.
  // use 0 to only rerender when items will come into view.
  overflowMargin: _propTypes.default.number,
  // the amount of items to add at the top and bottom to render,
  // so not every scroll of causes a rerender.
  overflowItems: _propTypes.default.number
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL2VsZW1lbnRzL0xhenlSZW5kZXJMaXN0LmpzIl0sIm5hbWVzIjpbIkl0ZW1SYW5nZSIsImNvbnN0cnVjdG9yIiwidG9wQ291bnQiLCJyZW5kZXJDb3VudCIsImJvdHRvbUNvdW50IiwiY29udGFpbnMiLCJyYW5nZSIsImV4cGFuZCIsImFtb3VudCIsInRvcEdyb3ciLCJNYXRoIiwibWluIiwiYm90dG9tR3JvdyIsInRvdGFsU2l6ZSIsIkxhenlSZW5kZXJMaXN0IiwiUmVhY3QiLCJDb21wb25lbnQiLCJwcm9wcyIsInN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0VmlzaWJsZVJhbmdlRnJvbVByb3BzIiwiaW50ZXJzZWN0UmFuZ2UiLCJvdmVyZmxvd01hcmdpbiIsInJlbmRlclJhbmdlIiwib3ZlcmZsb3dJdGVtcyIsImxpc3RIYXNDaGFuZ2VkU2l6ZSIsIml0ZW1zIiwiaXRlbUhlaWdodCIsInNjcm9sbFRvcCIsImhlaWdodCIsImxlbmd0aCIsIm1heCIsImZsb29yIiwiaXRlbXNBZnRlclRvcCIsInZpc2libGVJdGVtcyIsImNlaWwiLCJyZW5kZXIiLCJyZW5kZXJJdGVtIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJyZW5kZXJlZEl0ZW1zIiwic2xpY2UiLCJlbGVtZW50IiwiZWxlbWVudFByb3BzIiwiY2xhc3NOYW1lIiwiY3JlYXRlRWxlbWVudCIsIm1hcCIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsIm51bWJlciIsImlzUmVxdWlyZWQiLCJmdW5jIiwiYXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFqQkE7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxNQUFNQSxTQUFOLENBQWdCO0FBQ1pDLEVBQUFBLFdBQVcsQ0FBQ0MsUUFBRCxFQUFXQyxXQUFYLEVBQXdCQyxXQUF4QixFQUFxQztBQUM1QyxTQUFLRixR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QUw7QUFBN0MsT0FEUTtBQUVqQixtQkFBYSxLQUFLdEIsS0FBTCxDQUFXMkI7QUFGUCxLQUFyQjtBQUlBLFdBQU83QixlQUFNOEIsYUFBTixDQUFvQkgsT0FBcEIsRUFBNkJDLFlBQTdCLEVBQTJDSCxhQUFhLENBQUNNLEdBQWQsQ0FBa0JULFVBQWxCLENBQTNDLENBQVA7QUFDSDs7QUFqRHVEOzs7QUFvRDVEdkIsY0FBYyxDQUFDaUMsWUFBZixHQUE4QjtBQUMxQnZCLEVBQUFBLGFBQWEsRUFBRSxFQURXO0FBRTFCRixFQUFBQSxjQUFjLEVBQUU7QUFGVSxDQUE5QjtBQUtBUixjQUFjLENBQUNrQyxTQUFmLEdBQTJCO0FBQ3ZCO0FBQ0FyQixFQUFBQSxVQUFVLEVBQUVzQixtQkFBVUMsTUFBVixDQUFpQkMsVUFGTjtBQUd2QjtBQUNBZCxFQUFBQSxVQUFVLEVBQUVZLG1CQUFVRyxJQUFWLENBQWVELFVBSko7QUFLdkI7QUFDQXZCLEVBQUFBLFNBQVMsRUFBRXFCLG1CQUFVQyxNQUFWLENBQWlCQyxVQU5MO0FBT3ZCO0FBQ0F0QixFQUFBQSxNQUFNLEVBQUVvQixtQkFBVUMsTUFBVixDQUFpQkMsVUFSRjtBQVN2QjtBQUNBekIsRUFBQUEsS0FBSyxFQUFFdUIsbUJBQVVJLEtBVk07QUFXdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQS9CLEVBQUFBLGNBQWMsRUFBRTJCLG1CQUFVQyxNQWZIO0FBZ0J2QjtBQUNBO0FBQ0ExQixFQUFBQSxhQUFhLEVBQUV5QixtQkFBVUM7QUFsQkYsQ0FBM0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgTmV3IFZlY3RvciBMdGRcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5jbGFzcyBJdGVtUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHRvcENvdW50LCByZW5kZXJDb3VudCwgYm90dG9tQ291bnQpIHtcbiAgICAgICAgdGhpcy50b3BDb3VudCA9IHRvcENvdW50O1xuICAgICAgICB0aGlzLnJlbmRlckNvdW50ID0gcmVuZGVyQ291bnQ7XG4gICAgICAgIHRoaXMuYm90dG9tQ291bnQgPSBib3R0b21Db3VudDtcbiAgICB9XG5cbiAgICBjb250YWlucyhyYW5nZSkge1xuICAgICAgICAvLyBkb24ndCBjb250YWluIGVtcHR5IHJhbmdlc1xuICAgICAgICAvLyBhcyBpdCB3aWxsIHByZXZlbnQgY2xlYXJpbmcgdGhlIGxpc3RcbiAgICAgICAgLy8gb25jZSBpdCBpcyBzY3JvbGxlZCBmYXIgZW5vdWdoIG91dCBvZiB2aWV3XG4gICAgICAgIGlmICghcmFuZ2UucmVuZGVyQ291bnQgJiYgdGhpcy5yZW5kZXJDb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZS50b3BDb3VudCA+PSB0aGlzLnRvcENvdW50ICYmXG4gICAgICAgICAgICAocmFuZ2UudG9wQ291bnQgKyByYW5nZS5yZW5kZXJDb3VudCkgPD0gKHRoaXMudG9wQ291bnQgKyB0aGlzLnJlbmRlckNvdW50KTtcbiAgICB9XG5cbiAgICBleHBhbmQoYW1vdW50KSB7XG4gICAgICAgIC8vIGRvbid0IGV4cGFuZCByYW5nZXMgdGhhdCB3b24ndCByZW5kZXIgYW55dGhpbmdcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9wR3JvdyA9IE1hdGgubWluKGFtb3VudCwgdGhpcy50b3BDb3VudCk7XG4gICAgICAgIGNvbnN0IGJvdHRvbUdyb3cgPSBNYXRoLm1pbihhbW91bnQsIHRoaXMuYm90dG9tQ291bnQpO1xuICAgICAgICByZXR1cm4gbmV3IEl0ZW1SYW5nZShcbiAgICAgICAgICAgIHRoaXMudG9wQ291bnQgLSB0b3BHcm93LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDb3VudCArIHRvcEdyb3cgKyBib3R0b21Hcm93LFxuICAgICAgICAgICAgdGhpcy5ib3R0b21Db3VudCAtIGJvdHRvbUdyb3csXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdG90YWxTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BDb3VudCArIHRoaXMucmVuZGVyQ291bnQgKyB0aGlzLmJvdHRvbUNvdW50O1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF6eVJlbmRlckxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBMYXp5UmVuZGVyTGlzdC5nZXRWaXNpYmxlUmFuZ2VGcm9tUHJvcHMocHJvcHMpO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3RSYW5nZSA9IHJhbmdlLmV4cGFuZChwcm9wcy5vdmVyZmxvd01hcmdpbik7XG4gICAgICAgIGNvbnN0IHJlbmRlclJhbmdlID0gcmFuZ2UuZXhwYW5kKHByb3BzLm92ZXJmbG93SXRlbXMpO1xuICAgICAgICBjb25zdCBsaXN0SGFzQ2hhbmdlZFNpemUgPSAhIXN0YXRlLnJlbmRlclJhbmdlICYmIHJlbmRlclJhbmdlLnRvdGFsU2l6ZSgpICE9PSBzdGF0ZS5yZW5kZXJSYW5nZS50b3RhbFNpemUoKTtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgcmVuZGVyIFJhbmdlIGlmIHRoZSBsaXN0IGhhcyBzaHJ1bmsvZ3Jvd24gYW5kIHdlIG5lZWQgdG8gYWRqdXN0IHBhZGRpbmcgT1JcbiAgICAgICAgLy8gaWYgdGhlIG5ldyByYW5nZSArIG92ZXJmbG93TWFyZ2luIGlzbid0IGNvbnRhaW5lZCBieSB0aGUgb2xkIGFueW1vcmVcbiAgICAgICAgaWYgKGxpc3RIYXNDaGFuZ2VkU2l6ZSB8fCAhc3RhdGUucmVuZGVyUmFuZ2UgfHwgIXN0YXRlLnJlbmRlclJhbmdlLmNvbnRhaW5zKGludGVyc2VjdFJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtyZW5kZXJSYW5nZX07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFZpc2libGVSYW5nZUZyb21Qcm9wcyhwcm9wcykge1xuICAgICAgICBjb25zdCB7aXRlbXMsIGl0ZW1IZWlnaHQsIHNjcm9sbFRvcCwgaGVpZ2h0fSA9IHByb3BzO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDA7XG4gICAgICAgIGNvbnN0IHRvcENvdW50ID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihzY3JvbGxUb3AgLyBpdGVtSGVpZ2h0KSksIGxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGl0ZW1zQWZ0ZXJUb3AgPSBsZW5ndGggLSB0b3BDb3VudDtcbiAgICAgICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gaGVpZ2h0ICE9PSAwID8gTWF0aC5jZWlsKGhlaWdodCAvIGl0ZW1IZWlnaHQpIDogMDtcbiAgICAgICAgY29uc3QgcmVuZGVyQ291bnQgPSBNYXRoLm1pbih2aXNpYmxlSXRlbXMsIGl0ZW1zQWZ0ZXJUb3ApO1xuICAgICAgICBjb25zdCBib3R0b21Db3VudCA9IGl0ZW1zQWZ0ZXJUb3AgLSByZW5kZXJDb3VudDtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVtUmFuZ2UodG9wQ291bnQsIHJlbmRlckNvdW50LCBib3R0b21Db3VudCk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7aXRlbUhlaWdodCwgaXRlbXMsIHJlbmRlckl0ZW19ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3Qge3JlbmRlclJhbmdlfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHt0b3BDb3VudCwgcmVuZGVyQ291bnQsIGJvdHRvbUNvdW50fSA9IHJlbmRlclJhbmdlO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSB0b3BDb3VudCAqIGl0ZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdCb3R0b20gPSBib3R0b21Db3VudCAqIGl0ZW1IZWlnaHQ7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkSXRlbXMgPSAoaXRlbXMgfHwgW10pLnNsaWNlKFxuICAgICAgICAgICAgdG9wQ291bnQsXG4gICAgICAgICAgICB0b3BDb3VudCArIHJlbmRlckNvdW50LFxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByb3BzLmVsZW1lbnQgfHwgXCJkaXZcIjtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0ge1xuICAgICAgICAgICAgXCJzdHlsZVwiOiB7cGFkZGluZ1RvcDogYCR7cGFkZGluZ1RvcH1weGAsIHBhZGRpbmdCb3R0b206IGAke3BhZGRpbmdCb3R0b219cHhgfSxcbiAgICAgICAgICAgIFwiY2xhc3NOYW1lXCI6IHRoaXMucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChlbGVtZW50LCBlbGVtZW50UHJvcHMsIHJlbmRlcmVkSXRlbXMubWFwKHJlbmRlckl0ZW0pKTtcbiAgICB9XG59XG5cbkxhenlSZW5kZXJMaXN0LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBvdmVyZmxvd0l0ZW1zOiAyMCxcbiAgICBvdmVyZmxvd01hcmdpbjogNSxcbn07XG5cbkxhenlSZW5kZXJMaXN0LnByb3BUeXBlcyA9IHtcbiAgICAvLyBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBjb21wb25lbnQgcmV0dXJuZWQgYnkgYHJlbmRlckl0ZW1gXG4gICAgaXRlbUhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIC8vIGZ1bmN0aW9uIHRvIHR1cm4gYW4gZWxlbWVudCBvZiBgaXRlbXNgIGludG8gYSByZWFjdCBjb21wb25lbnRcbiAgICByZW5kZXJJdGVtOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIC8vIHNjcm9sbFRvcCBvZiB0aGUgdmlld3BvcnQgKG1pbnVzIHRoZSBoZWlnaHQgb2YgYW55IGNvbnRlbnQgYWJvdmUgdGhpcyBsaXN0IGxpa2Ugb3RoZXIgYExhenlSZW5kZXJMaXN0YHMpXG4gICAgc2Nyb2xsVG9wOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgLy8gdGhlIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgdGhpcyBjb250ZW50IGlzIHNjcm9sbGVkIGluXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgLy8gYWxsIGl0ZW1zIGZvciB0aGUgbGlzdC4gVGhlc2Ugc2hvdWxkIG5vdCBiZSByZWFjdCBjb21wb25lbnRzLCBzZWUgYHJlbmRlckl0ZW1gLlxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXksXG4gICAgLy8gdGhlIGFtb3VudCBvZiBpdGVtcyB0byBzY3JvbGwgYmVmb3JlIGNhdXNpbmcgYSByZXJlbmRlcixcbiAgICAvLyBzaG91bGQgdHlwaWNhbGx5IGJlIGxlc3MgdGhhbiBgb3ZlcmZsb3dJdGVtc2AgdW5sZXNzIGFwcGx5aW5nXG4gICAgLy8gbWFyZ2lucyBpbiB0aGUgcGFyZW50IGNvbXBvbmVudCB3aGVuIHVzaW5nIG11bHRpcGxlIExhenlSZW5kZXJMaXN0IGluIG9uZSB2aWV3cG9ydC5cbiAgICAvLyB1c2UgMCB0byBvbmx5IHJlcmVuZGVyIHdoZW4gaXRlbXMgd2lsbCBjb21lIGludG8gdmlldy5cbiAgICBvdmVyZmxvd01hcmdpbjogUHJvcFR5cGVzLm51bWJlcixcbiAgICAvLyB0aGUgYW1vdW50IG9mIGl0ZW1zIHRvIGFkZCBhdCB0aGUgdG9wIGFuZCBib3R0b20gdG8gcmVuZGVyLFxuICAgIC8vIHNvIG5vdCBldmVyeSBzY3JvbGwgb2YgY2F1c2VzIGEgcmVyZW5kZXIuXG4gICAgb3ZlcmZsb3dJdGVtczogUHJvcFR5cGVzLm51bWJlcixcbn07XG4iXX0=