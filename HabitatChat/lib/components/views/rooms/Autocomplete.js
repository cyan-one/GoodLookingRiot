"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.generateCompletionDomId = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _classnames = _interopRequireDefault(require("classnames"));

var _flatMap = _interopRequireDefault(require("lodash/flatMap"));

var _Autocompleter = _interopRequireWildcard(require("../../../autocomplete/Autocompleter"));

var _SettingsStore = _interopRequireDefault(require("../../../settings/SettingsStore"));

/*
Copyright 2016 Aviral Dasgupta
Copyright 2017 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
const COMPOSER_SELECTED = 0;

const generateCompletionDomId = number => "mx_Autocomplete_Completion_".concat(number);

exports.generateCompletionDomId = generateCompletionDomId;

class Autocomplete extends _react.default.PureComponent
/*:: <IProps, IState>*/
{
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "autocompleter", void 0);
    (0, _defineProperty2.default)(this, "queryRequested", void 0);
    (0, _defineProperty2.default)(this, "debounceCompletionsRequest", void 0);
    (0, _defineProperty2.default)(this, "containerRef", void 0);
    (0, _defineProperty2.default)(this, "hide", () => {
      this.setState({
        hide: true,
        selectionOffset: 0,
        completions: [],
        completionList: []
      });
    });
    (0, _defineProperty2.default)(this, "onCompletionClicked", (selectionOffset
    /*: number*/
    ) =>
    /*: boolean*/
    {
      if (this.countCompletions() === 0 || selectionOffset === COMPOSER_SELECTED) {
        return false;
      }

      this.props.onConfirm(this.state.completionList[selectionOffset - 1]);
      this.hide();
      return true;
    });
    this.autocompleter = new _Autocompleter.default(props.room);
    this.state = {
      // list of completionResults, each containing completions
      completions: [],
      // array of completions, so we can look up current selection by offset quickly
      completionList: [],
      // how far down the completion list we are (THIS IS 1-INDEXED!)
      selectionOffset: COMPOSER_SELECTED,
      // whether we should show completions if they're available
      shouldShowCompletions: true,
      hide: false,
      forceComplete: false
    };
    this.containerRef = _react.default.createRef();
  }

  componentDidMount() {
    this.applyNewProps();
  }

  applyNewProps(oldQuery
  /*: string*/
  , oldRoom
  /*: Room*/
  ) {
    if (oldRoom && this.props.room.roomId !== oldRoom.roomId) {
      this.autocompleter.destroy();
      this.autocompleter = new _Autocompleter.default(this.props.room);
    } // Query hasn't changed so don't try to complete it


    if (oldQuery === this.props.query) {
      return;
    }

    this.complete(this.props.query, this.props.selection);
  }

  componentWillUnmount() {
    this.autocompleter.destroy();
  }

  complete(query
  /*: string*/
  , selection
  /*: ISelectionRange*/
  ) {
    this.queryRequested = query;

    if (this.debounceCompletionsRequest) {
      clearTimeout(this.debounceCompletionsRequest);
    }

    if (query === "") {
      this.setState({
        // Clear displayed completions
        completions: [],
        completionList: [],
        // Reset selected completion
        selectionOffset: COMPOSER_SELECTED,
        // Hide the autocomplete box
        hide: true
      });
      return Promise.resolve(null);
    }

    let autocompleteDelay = _SettingsStore.default.getValue("autocompleteDelay"); // Don't debounce if we are already showing completions


    if (this.state.completions.length > 0 || this.state.forceComplete) {
      autocompleteDelay = 0;
    }

    return new Promise(resolve => {
      this.debounceCompletionsRequest = setTimeout(() => {
        resolve(this.processQuery(query, selection));
      }, autocompleteDelay);
    });
  }

  processQuery(query
  /*: string*/
  , selection
  /*: ISelectionRange*/
  ) {
    return this.autocompleter.getCompletions(query, selection, this.state.forceComplete).then(completions => {
      // Only ever process the completions for the most recent query being processed
      if (query !== this.queryRequested) {
        return;
      }

      this.processCompletions(completions);
    });
  }

  processCompletions(completions
  /*: IProviderCompletions[]*/
  ) {
    const completionList = (0, _flatMap.default)(completions, provider => provider.completions); // Reset selection when completion list becomes empty.

    let selectionOffset = COMPOSER_SELECTED;

    if (completionList.length > 0) {
      /* If the currently selected completion is still in the completion list,
       try to find it and jump to it. If not, select composer.
       */
      const currentSelection = this.state.selectionOffset === 0 ? null : this.state.completionList[this.state.selectionOffset - 1].completion;
      selectionOffset = completionList.findIndex(completion => completion.completion === currentSelection);

      if (selectionOffset === -1) {
        selectionOffset = COMPOSER_SELECTED;
      } else {
        selectionOffset++; // selectionOffset is 1-indexed!
      }
    }

    let hide = this.state.hide; // If `completion.command.command` is truthy, then a provider has matched with the query

    const anyMatches = completions.some(completion => !!completion.command.command);
    hide = !anyMatches;
    this.setState({
      completions,
      completionList,
      selectionOffset,
      hide,
      // Force complete is turned off each time since we can't edit the query in that case
      forceComplete: false
    });
  }

  hasSelection()
  /*: boolean*/
  {
    return this.countCompletions() > 0 && this.state.selectionOffset !== 0;
  }

  countCompletions()
  /*: number*/
  {
    return this.state.completionList.length;
  } // called from MessageComposerInput


  moveSelection(delta
  /*: number*/
  ) {
    const completionCount = this.countCompletions();
    if (completionCount === 0) return; // there are no items to move the selection through
    // Note: selectionOffset 0 represents the unsubstituted text, while 1 means first pill selected

    const index = (this.state.selectionOffset + delta + completionCount + 1) % (completionCount + 1);
    this.setSelection(index);
  }

  onEscape(e
  /*: KeyboardEvent*/
  )
  /*: boolean*/
  {
    const completionCount = this.countCompletions();

    if (completionCount === 0) {
      // autocomplete is already empty, so don't preventDefault
      return;
    }

    e.preventDefault(); // selectionOffset = 0, so we don't end up completing when autocomplete is hidden

    this.hide();
  }

  forceComplete() {
    return new Promise(resolve => {
      this.setState({
        forceComplete: true,
        hide: false
      }, () => {
        this.complete(this.props.query, this.props.selection).then(() => {
          resolve(this.countCompletions());
        });
      });
    });
  }

  setSelection(selectionOffset
  /*: number*/
  ) {
    this.setState({
      selectionOffset,
      hide: false
    });

    if (this.props.onSelectionChange) {
      this.props.onSelectionChange(this.state.completionList[selectionOffset - 1], selectionOffset - 1);
    }
  }

  componentDidUpdate(prevProps
  /*: IProps*/
  ) {
    this.applyNewProps(prevProps.query, prevProps.room); // this is the selected completion, so scroll it into view if needed

    const selectedCompletion = this.refs["completion".concat(this.state.selectionOffset)];

    if (selectedCompletion && this.containerRef.current) {
      const domNode = _reactDom.default.findDOMNode(selectedCompletion);

      const offsetTop = domNode && domNode.offsetTop;

      if (offsetTop > this.containerRef.current.scrollTop + this.containerRef.current.offsetHeight || offsetTop < this.containerRef.current.scrollTop) {
        this.containerRef.current.scrollTop = offsetTop - this.containerRef.current.offsetTop;
      }
    }
  }

  render() {
    let position = 1;
    const renderedCompletions = this.state.completions.map((completionResult, i) => {
      const completions = completionResult.completions.map((completion, j) => {
        const selected = position === this.state.selectionOffset;
        const className = (0, _classnames.default)('mx_Autocomplete_Completion', {
          selected
        });
        const componentPosition = position;
        position++;

        const onClick = () => {
          this.onCompletionClicked(componentPosition);
        };

        return _react.default.cloneElement(completion.component, {
          "key": j,
          "ref": "completion".concat(componentPosition),
          "id": generateCompletionDomId(componentPosition - 1),
          // 0 index the completion IDs
          className,
          onClick,
          "aria-selected": selected
        });
      });
      return completions.length > 0 ? /*#__PURE__*/_react.default.createElement("div", {
        key: i,
        className: "mx_Autocomplete_ProviderSection"
      }, /*#__PURE__*/_react.default.createElement("div", {
        className: "mx_Autocomplete_provider_name"
      }, completionResult.provider.getName()), completionResult.provider.renderCompletions(completions)) : null;
    }).filter(completion => !!completion);
    return !this.state.hide && renderedCompletions.length > 0 ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_Autocomplete",
      ref: this.containerRef
    }, renderedCompletions) : null;
  }

}

exports.default = Autocomplete;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL3Jvb21zL0F1dG9jb21wbGV0ZS50c3giXSwibmFtZXMiOlsiQ09NUE9TRVJfU0VMRUNURUQiLCJnZW5lcmF0ZUNvbXBsZXRpb25Eb21JZCIsIm51bWJlciIsIkF1dG9jb21wbGV0ZSIsIlJlYWN0IiwiUHVyZUNvbXBvbmVudCIsImNvbnN0cnVjdG9yIiwicHJvcHMiLCJzZXRTdGF0ZSIsImhpZGUiLCJzZWxlY3Rpb25PZmZzZXQiLCJjb21wbGV0aW9ucyIsImNvbXBsZXRpb25MaXN0IiwiY291bnRDb21wbGV0aW9ucyIsIm9uQ29uZmlybSIsInN0YXRlIiwiYXV0b2NvbXBsZXRlciIsIkF1dG9jb21wbGV0ZXIiLCJyb29tIiwic2hvdWxkU2hvd0NvbXBsZXRpb25zIiwiZm9yY2VDb21wbGV0ZSIsImNvbnRhaW5lclJlZiIsImNyZWF0ZVJlZiIsImNvbXBvbmVudERpZE1vdW50IiwiYXBwbHlOZXdQcm9wcyIsIm9sZFF1ZXJ5Iiwib2xkUm9vbSIsInJvb21JZCIsImRlc3Ryb3kiLCJxdWVyeSIsImNvbXBsZXRlIiwic2VsZWN0aW9uIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJxdWVyeVJlcXVlc3RlZCIsImRlYm91bmNlQ29tcGxldGlvbnNSZXF1ZXN0IiwiY2xlYXJUaW1lb3V0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJhdXRvY29tcGxldGVEZWxheSIsIlNldHRpbmdzU3RvcmUiLCJnZXRWYWx1ZSIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJwcm9jZXNzUXVlcnkiLCJnZXRDb21wbGV0aW9ucyIsInRoZW4iLCJwcm9jZXNzQ29tcGxldGlvbnMiLCJwcm92aWRlciIsImN1cnJlbnRTZWxlY3Rpb24iLCJjb21wbGV0aW9uIiwiZmluZEluZGV4IiwiYW55TWF0Y2hlcyIsInNvbWUiLCJjb21tYW5kIiwiaGFzU2VsZWN0aW9uIiwibW92ZVNlbGVjdGlvbiIsImRlbHRhIiwiY29tcGxldGlvbkNvdW50IiwiaW5kZXgiLCJzZXRTZWxlY3Rpb24iLCJvbkVzY2FwZSIsImUiLCJwcmV2ZW50RGVmYXVsdCIsIm9uU2VsZWN0aW9uQ2hhbmdlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwic2VsZWN0ZWRDb21wbGV0aW9uIiwicmVmcyIsImN1cnJlbnQiLCJkb21Ob2RlIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsIm9mZnNldFRvcCIsInNjcm9sbFRvcCIsIm9mZnNldEhlaWdodCIsInJlbmRlciIsInBvc2l0aW9uIiwicmVuZGVyZWRDb21wbGV0aW9ucyIsIm1hcCIsImNvbXBsZXRpb25SZXN1bHQiLCJpIiwiaiIsInNlbGVjdGVkIiwiY2xhc3NOYW1lIiwiY29tcG9uZW50UG9zaXRpb24iLCJvbkNsaWNrIiwib25Db21wbGV0aW9uQ2xpY2tlZCIsImNsb25lRWxlbWVudCIsImNvbXBvbmVudCIsImdldE5hbWUiLCJyZW5kZXJDb21wbGV0aW9ucyIsImZpbHRlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFHQTs7QUF4QkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQkEsTUFBTUEsaUJBQWlCLEdBQUcsQ0FBMUI7O0FBRU8sTUFBTUMsdUJBQXVCLEdBQUlDLE1BQUQseUNBQTBDQSxNQUExQyxDQUFoQzs7OztBQXVCUSxNQUFNQyxZQUFOLFNBQTJCQyxlQUFNQztBQUFqQztBQUErRDtBQU0xRUMsRUFBQUEsV0FBVyxDQUFDQyxLQUFELEVBQVE7QUFDZixVQUFNQSxLQUFOO0FBRGU7QUFBQTtBQUFBO0FBQUE7QUFBQSxnREE2SlosTUFBTTtBQUNULFdBQUtDLFFBQUwsQ0FBYztBQUNWQyxRQUFBQSxJQUFJLEVBQUUsSUFESTtBQUVWQyxRQUFBQSxlQUFlLEVBQUUsQ0FGUDtBQUdWQyxRQUFBQSxXQUFXLEVBQUUsRUFISDtBQUlWQyxRQUFBQSxjQUFjLEVBQUU7QUFKTixPQUFkO0FBTUgsS0FwS2tCO0FBQUEsK0RBbUxHLENBQUNGO0FB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IjpbIi8qXG5Db3B5cmlnaHQgMjAxNiBBdmlyYWwgRGFzZ3VwdGFcbkNvcHlyaWdodCAyMDE3IE5ldyBWZWN0b3IgTHRkXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgZmxhdE1hcCBmcm9tICdsb2Rhc2gvZmxhdE1hcCc7XG5pbXBvcnQge0lDb21wbGV0aW9uLCBJU2VsZWN0aW9uUmFuZ2UsIElQcm92aWRlckNvbXBsZXRpb25zfSBmcm9tICcuLi8uLi8uLi9hdXRvY29tcGxldGUvQXV0b2NvbXBsZXRlcic7XG5pbXBvcnQge1Jvb219IGZyb20gJ21hdHJpeC1qcy1zZGsvc3JjL21vZGVscy9yb29tJztcblxuaW1wb3J0IFNldHRpbmdzU3RvcmUgZnJvbSBcIi4uLy4uLy4uL3NldHRpbmdzL1NldHRpbmdzU3RvcmVcIjtcbmltcG9ydCBBdXRvY29tcGxldGVyIGZyb20gJy4uLy4uLy4uL2F1dG9jb21wbGV0ZS9BdXRvY29tcGxldGVyJztcblxuY29uc3QgQ09NUE9TRVJfU0VMRUNURUQgPSAwO1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVDb21wbGV0aW9uRG9tSWQgPSAobnVtYmVyKSA9PiBgbXhfQXV0b2NvbXBsZXRlX0NvbXBsZXRpb25fJHtudW1iZXJ9YDtcblxuaW50ZXJmYWNlIElQcm9wcyB7XG4gICAgLy8gdGhlIHF1ZXJ5IHN0cmluZyBmb3Igd2hpY2ggdG8gc2hvdyBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcbiAgICBxdWVyeTogc3RyaW5nO1xuICAgIC8vIG1ldGhvZCBpbnZva2VkIHdpdGggcmFuZ2UgYW5kIHRleHQgY29udGVudCB3aGVuIGNvbXBsZXRpb24gaXMgY29uZmlybWVkXG4gICAgb25Db25maXJtOiAoSUNvbXBsZXRpb24pID0+IHZvaWQ7XG4gICAgLy8gbWV0aG9kIGludm9rZWQgd2hlbiBzZWxlY3RlZCAoaWYgYW55KSBjb21wbGV0aW9uIGNoYW5nZXNcbiAgICBvblNlbGVjdGlvbkNoYW5nZT86IChJQ29tcGxldGlvbiwgbnVtYmVyKSA9PiB2b2lkO1xuICAgIHNlbGVjdGlvbjogSVNlbGVjdGlvblJhbmdlO1xuICAgIC8vIFRoZSByb29tIGluIHdoaWNoIHdlJ3JlIGF1dG9jb21wbGV0aW5nXG4gICAgcm9vbTogUm9vbTtcbn1cblxuaW50ZXJmYWNlIElTdGF0ZSB7XG4gICAgY29tcGxldGlvbnM6IElQcm92aWRlckNvbXBsZXRpb25zW107XG4gICAgY29tcGxldGlvbkxpc3Q6IElDb21wbGV0aW9uW107XG4gICAgc2VsZWN0aW9uT2Zmc2V0OiBudW1iZXI7XG4gICAgc2hvdWxkU2hvd0NvbXBsZXRpb25zOiBib29sZWFuO1xuICAgIGhpZGU6IGJvb2xlYW47XG4gICAgZm9yY2VDb21wbGV0ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXV0b2NvbXBsZXRlIGV4dGVuZHMgUmVhY3QuUHVyZUNvbXBvbmVudDxJUHJvcHMsIElTdGF0ZT4ge1xuICAgIGF1dG9jb21wbGV0ZXI6IEF1dG9jb21wbGV0ZXI7XG4gICAgcXVlcnlSZXF1ZXN0ZWQ6IHN0cmluZztcbiAgICBkZWJvdW5jZUNvbXBsZXRpb25zUmVxdWVzdDogTm9kZUpTLlRpbWVvdXQ7XG4gICAgY29udGFpbmVyUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTERpdkVsZW1lbnQ+O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlciA9IG5ldyBBdXRvY29tcGxldGVyKHByb3BzLnJvb20pO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAvLyBsaXN0IG9mIGNvbXBsZXRpb25SZXN1bHRzLCBlYWNoIGNvbnRhaW5pbmcgY29tcGxldGlvbnNcbiAgICAgICAgICAgIGNvbXBsZXRpb25zOiBbXSxcblxuICAgICAgICAgICAgLy8gYXJyYXkgb2YgY29tcGxldGlvbnMsIHNvIHdlIGNhbiBsb29rIHVwIGN1cnJlbnQgc2VsZWN0aW9uIGJ5IG9mZnNldCBxdWlja2x5XG4gICAgICAgICAgICBjb21wbGV0aW9uTGlzdDogW10sXG5cbiAgICAgICAgICAgIC8vIGhvdyBmYXIgZG93biB0aGUgY29tcGxldGlvbiBsaXN0IHdlIGFyZSAoVEhJUyBJUyAxLUlOREVYRUQhKVxuICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0OiBDT01QT1NFUl9TRUxFQ1RFRCxcblxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSBzaG91bGQgc2hvdyBjb21wbGV0aW9ucyBpZiB0aGV5J3JlIGF2YWlsYWJsZVxuICAgICAgICAgICAgc2hvdWxkU2hvd0NvbXBsZXRpb25zOiB0cnVlLFxuXG4gICAgICAgICAgICBoaWRlOiBmYWxzZSxcblxuICAgICAgICAgICAgZm9yY2VDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5hcHBseU5ld1Byb3BzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhcHBseU5ld1Byb3BzKG9sZFF1ZXJ5Pzogc3RyaW5nLCBvbGRSb29tPzogUm9vbSkge1xuICAgICAgICBpZiAob2xkUm9vbSAmJiB0aGlzLnByb3BzLnJvb20ucm9vbUlkICE9PSBvbGRSb29tLnJvb21JZCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlciA9IG5ldyBBdXRvY29tcGxldGVyKHRoaXMucHJvcHMucm9vbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBRdWVyeSBoYXNuJ3QgY2hhbmdlZCBzbyBkb24ndCB0cnkgdG8gY29tcGxldGUgaXRcbiAgICAgICAgaWYgKG9sZFF1ZXJ5ID09PSB0aGlzLnByb3BzLnF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbXBsZXRlKHRoaXMucHJvcHMucXVlcnksIHRoaXMucHJvcHMuc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBjb21wbGV0ZShxdWVyeTogc3RyaW5nLCBzZWxlY3Rpb246IElTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5UmVxdWVzdGVkID0gcXVlcnk7XG4gICAgICAgIGlmICh0aGlzLmRlYm91bmNlQ29tcGxldGlvbnNSZXF1ZXN0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZUNvbXBsZXRpb25zUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBkaXNwbGF5ZWQgY29tcGxldGlvbnNcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uczogW10sXG4gICAgICAgICAgICAgICAgY29tcGxldGlvbkxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHNlbGVjdGVkIGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25PZmZzZXQ6IENPTVBPU0VSX1NFTEVDVEVELFxuICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIGF1dG9jb21wbGV0ZSBib3hcbiAgICAgICAgICAgICAgICBoaWRlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhdXRvY29tcGxldGVEZWxheSA9IFNldHRpbmdzU3RvcmUuZ2V0VmFsdWUoXCJhdXRvY29tcGxldGVEZWxheVwiKTtcblxuICAgICAgICAvLyBEb24ndCBkZWJvdW5jZSBpZiB3ZSBhcmUgYWxyZWFkeSBzaG93aW5nIGNvbXBsZXRpb25zXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNvbXBsZXRpb25zLmxlbmd0aCA+IDAgfHwgdGhpcy5zdGF0ZS5mb3JjZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhdXRvY29tcGxldGVEZWxheSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VDb21wbGV0aW9uc1JlcXVlc3QgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucHJvY2Vzc1F1ZXJ5KHF1ZXJ5LCBzZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIH0sIGF1dG9jb21wbGV0ZURlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc1F1ZXJ5KHF1ZXJ5OiBzdHJpbmcsIHNlbGVjdGlvbjogSVNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dG9jb21wbGV0ZXIuZ2V0Q29tcGxldGlvbnMoXG4gICAgICAgICAgICBxdWVyeSwgc2VsZWN0aW9uLCB0aGlzLnN0YXRlLmZvcmNlQ29tcGxldGUsXG4gICAgICAgICkudGhlbigoY29tcGxldGlvbnMpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgZXZlciBwcm9jZXNzIHRoZSBjb21wbGV0aW9ucyBmb3IgdGhlIG1vc3QgcmVjZW50IHF1ZXJ5IGJlaW5nIHByb2Nlc3NlZFxuICAgICAgICAgICAgaWYgKHF1ZXJ5ICE9PSB0aGlzLnF1ZXJ5UmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQ29tcGxldGlvbnMoY29tcGxldGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm9jZXNzQ29tcGxldGlvbnMoY29tcGxldGlvbnM6IElQcm92aWRlckNvbXBsZXRpb25zW10pIHtcbiAgICAgICAgY29uc3QgY29tcGxldGlvbkxpc3QgPSBmbGF0TWFwKGNvbXBsZXRpb25zLCAocHJvdmlkZXIpID0+IHByb3ZpZGVyLmNvbXBsZXRpb25zKTtcblxuICAgICAgICAvLyBSZXNldCBzZWxlY3Rpb24gd2hlbiBjb21wbGV0aW9uIGxpc3QgYmVjb21lcyBlbXB0eS5cbiAgICAgICAgbGV0IHNlbGVjdGlvbk9mZnNldCA9IENPTVBPU0VSX1NFTEVDVEVEO1xuICAgICAgICBpZiAoY29tcGxldGlvbkxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLyogSWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb21wbGV0aW9uIGlzIHN0aWxsIGluIHRoZSBjb21wbGV0aW9uIGxpc3QsXG4gICAgICAgICAgICAgdHJ5IHRvIGZpbmQgaXQgYW5kIGp1bXAgdG8gaXQuIElmIG5vdCwgc2VsZWN0IGNvbXBvc2VyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25PZmZzZXQgPT09IDAgPyBudWxsIDpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNvbXBsZXRpb25MaXN0W3RoaXMuc3RhdGUuc2VsZWN0aW9uT2Zmc2V0IC0gMV0uY29tcGxldGlvbjtcbiAgICAgICAgICAgIHNlbGVjdGlvbk9mZnNldCA9IGNvbXBsZXRpb25MaXN0LmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAoY29tcGxldGlvbikgPT4gY29tcGxldGlvbi5jb21wbGV0aW9uID09PSBjdXJyZW50U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25PZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0ID0gQ09NUE9TRVJfU0VMRUNURUQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk9mZnNldCsrOyAvLyBzZWxlY3Rpb25PZmZzZXQgaXMgMS1pbmRleGVkIVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhpZGUgPSB0aGlzLnN0YXRlLmhpZGU7XG4gICAgICAgIC8vIElmIGBjb21wbGV0aW9uLmNvbW1hbmQuY29tbWFuZGAgaXMgdHJ1dGh5LCB0aGVuIGEgcHJvdmlkZXIgaGFzIG1hdGNoZWQgd2l0aCB0aGUgcXVlcnlcbiAgICAgICAgY29uc3QgYW55TWF0Y2hlcyA9IGNvbXBsZXRpb25zLnNvbWUoKGNvbXBsZXRpb24pID0+ICEhY29tcGxldGlvbi5jb21tYW5kLmNvbW1hbmQpO1xuICAgICAgICBoaWRlID0gIWFueU1hdGNoZXM7XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBjb21wbGV0aW9ucyxcbiAgICAgICAgICAgIGNvbXBsZXRpb25MaXN0LFxuICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0LFxuICAgICAgICAgICAgaGlkZSxcbiAgICAgICAgICAgIC8vIEZvcmNlIGNvbXBsZXRlIGlzIHR1cm5lZCBvZmYgZWFjaCB0aW1lIHNpbmNlIHdlIGNhbid0IGVkaXQgdGhlIHF1ZXJ5IGluIHRoYXQgY2FzZVxuICAgICAgICAgICAgZm9yY2VDb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhc1NlbGVjdGlvbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb21wbGV0aW9ucygpID4gMCAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbk9mZnNldCAhPT0gMDtcbiAgICB9XG5cbiAgICBjb3VudENvbXBsZXRpb25zKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbXBsZXRpb25MaXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZnJvbSBNZXNzYWdlQ29tcG9zZXJJbnB1dFxuICAgIG1vdmVTZWxlY3Rpb24oZGVsdGE6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjb21wbGV0aW9uQ291bnQgPSB0aGlzLmNvdW50Q29tcGxldGlvbnMoKTtcbiAgICAgICAgaWYgKGNvbXBsZXRpb25Db3VudCA9PT0gMCkgcmV0dXJuOyAvLyB0aGVyZSBhcmUgbm8gaXRlbXMgdG8gbW92ZSB0aGUgc2VsZWN0aW9uIHRocm91Z2hcblxuICAgICAgICAvLyBOb3RlOiBzZWxlY3Rpb25PZmZzZXQgMCByZXByZXNlbnRzIHRoZSB1bnN1YnN0aXR1dGVkIHRleHQsIHdoaWxlIDEgbWVhbnMgZmlyc3QgcGlsbCBzZWxlY3RlZFxuICAgICAgICBjb25zdCBpbmRleCA9ICh0aGlzLnN0YXRlLnNlbGVjdGlvbk9mZnNldCArIGRlbHRhICsgY29tcGxldGlvbkNvdW50ICsgMSkgJSAoY29tcGxldGlvbkNvdW50ICsgMSk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKGluZGV4KTtcbiAgICB9XG5cbiAgICBvbkVzY2FwZShlOiBLZXlib2FyZEV2ZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRpb25Db3VudCA9IHRoaXMuY291bnRDb21wbGV0aW9ucygpO1xuICAgICAgICBpZiAoY29tcGxldGlvbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBhdXRvY29tcGxldGUgaXMgYWxyZWFkeSBlbXB0eSwgc28gZG9uJ3QgcHJldmVudERlZmF1bHRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBzZWxlY3Rpb25PZmZzZXQgPSAwLCBzbyB3ZSBkb24ndCBlbmQgdXAgY29tcGxldGluZyB3aGVuIGF1dG9jb21wbGV0ZSBpcyBoaWRkZW5cbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgaGlkZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBoaWRlOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uT2Zmc2V0OiAwLFxuICAgICAgICAgICAgY29tcGxldGlvbnM6IFtdLFxuICAgICAgICAgICAgY29tcGxldGlvbkxpc3Q6IFtdLFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yY2VDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBmb3JjZUNvbXBsZXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhpZGU6IGZhbHNlLFxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUodGhpcy5wcm9wcy5xdWVyeSwgdGhpcy5wcm9wcy5zZWxlY3Rpb24pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuY291bnRDb21wbGV0aW9ucygpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkNvbXBsZXRpb25DbGlja2VkID0gKHNlbGVjdGlvbk9mZnNldDogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50Q29tcGxldGlvbnMoKSA9PT0gMCB8fCBzZWxlY3Rpb25PZmZzZXQgPT09IENPTVBPU0VSX1NFTEVDVEVEKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnByb3BzLm9uQ29uZmlybSh0aGlzLnN0YXRlLmNvbXBsZXRpb25MaXN0W3NlbGVjdGlvbk9mZnNldCAtIDFdKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIHNldFNlbGVjdGlvbihzZWxlY3Rpb25PZmZzZXQ6IG51bWJlcikge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtzZWxlY3Rpb25PZmZzZXQsIGhpZGU6IGZhbHNlfSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0aW9uQ2hhbmdlKHRoaXMuc3RhdGUuY29tcGxldGlvbkxpc3Rbc2VsZWN0aW9uT2Zmc2V0IC0gMV0sIHNlbGVjdGlvbk9mZnNldCAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wczogSVByb3BzKSB7XG4gICAgICAgIHRoaXMuYXBwbHlOZXdQcm9wcyhwcmV2UHJvcHMucXVlcnksIHByZXZQcm9wcy5yb29tKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2VsZWN0ZWQgY29tcGxldGlvbiwgc28gc2Nyb2xsIGl0IGludG8gdmlldyBpZiBuZWVkZWRcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRDb21wbGV0aW9uID0gdGhpcy5yZWZzW2Bjb21wbGV0aW9uJHt0aGlzLnN0YXRlLnNlbGVjdGlvbk9mZnNldH1gXTtcbiAgICAgICAgaWYgKHNlbGVjdGVkQ29tcGxldGlvbiAmJiB0aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUoc2VsZWN0ZWRDb21wbGV0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcCA9IGRvbU5vZGUgJiYgKGRvbU5vZGUgYXMgSFRNTEVsZW1lbnQpLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGlmIChvZmZzZXRUb3AgPiB0aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50LnNjcm9sbFRvcCArIHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQub2Zmc2V0SGVpZ2h0IHx8XG4gICAgICAgICAgICAgICAgb2Zmc2V0VG9wIDwgdGhpcy5jb250YWluZXJSZWYuY3VycmVudC5zY3JvbGxUb3ApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50LnNjcm9sbFRvcCA9IG9mZnNldFRvcCAtIHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgcG9zaXRpb24gPSAxO1xuICAgICAgICBjb25zdCByZW5kZXJlZENvbXBsZXRpb25zID0gdGhpcy5zdGF0ZS5jb21wbGV0aW9ucy5tYXAoKGNvbXBsZXRpb25SZXN1bHQsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25zID0gY29tcGxldGlvblJlc3VsdC5jb21wbGV0aW9ucy5tYXAoKGNvbXBsZXRpb24sIGopID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHBvc2l0aW9uID09PSB0aGlzLnN0YXRlLnNlbGVjdGlvbk9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzKCdteF9BdXRvY29tcGxldGVfQ29tcGxldGlvbicsIHtzZWxlY3RlZH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgcG9zaXRpb24rKztcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0aW9uQ2xpY2tlZChjb21wb25lbnRQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY29tcGxldGlvbi5jb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJrZXlcIjogaixcbiAgICAgICAgICAgICAgICAgICAgXCJyZWZcIjogYGNvbXBsZXRpb24ke2NvbXBvbmVudFBvc2l0aW9ufWAsXG4gICAgICAgICAgICAgICAgICAgIFwiaWRcIjogZ2VuZXJhdGVDb21wbGV0aW9uRG9tSWQoY29tcG9uZW50UG9zaXRpb24gLSAxKSwgLy8gMCBpbmRleCB0aGUgY29tcGxldGlvbiBJRHNcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGlvbnMubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwibXhfQXV0b2NvbXBsZXRlX1Byb3ZpZGVyU2VjdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0F1dG9jb21wbGV0ZV9wcm92aWRlcl9uYW1lXCI+eyBjb21wbGV0aW9uUmVzdWx0LnByb3ZpZGVyLmdldE5hbWUoKSB9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHsgY29tcGxldGlvblJlc3VsdC5wcm92aWRlci5yZW5kZXJDb21wbGV0aW9ucyhjb21wbGV0aW9ucykgfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IG51bGw7XG4gICAgICAgIH0pLmZpbHRlcigoY29tcGxldGlvbikgPT4gISFjb21wbGV0aW9uKTtcblxuICAgICAgICByZXR1cm4gIXRoaXMuc3RhdGUuaGlkZSAmJiByZW5kZXJlZENvbXBsZXRpb25zLmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm14X0F1dG9jb21wbGV0ZVwiIHJlZj17dGhpcy5jb250YWluZXJSZWZ9PlxuICAgICAgICAgICAgICAgIHsgcmVuZGVyZWRDb21wbGV0aW9ucyB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKSA6IG51bGw7XG4gICAgfVxufVxuIl19