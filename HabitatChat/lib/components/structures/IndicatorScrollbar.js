"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _AutoHideScrollbar = _interopRequireDefault(require("./AutoHideScrollbar"));

/*
Copyright 2018 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class IndicatorScrollbar extends _react.default.Component {
  constructor(props) {
    super(props);
    (0, _defineProperty2.default)(this, "onMouseWheel", e => {
      if (this.props.verticalScrollsHorizontally && this._scrollElement) {
        // xyThreshold is the amount of horizontal motion required for the component to
        // ignore the vertical delta in a scroll. Used to stop trackpads from acting in
        // strange ways. Should be positive.
        const xyThreshold = 0; // yRetention is the factor multiplied by the vertical delta to try and reduce
        // the harshness of the scroll behaviour. Should be a value between 0 and 1.

        const yRetention = 1.0; // whenever we see horizontal scrolling, assume the user is on a trackpad
        // for at least the next 1 minute.

        const now = new Date().getTime();

        if (Math.abs(e.deltaX) > 0) {
          this._likelyTrackpadUser = true;
          this._checkAgainForTrackpad = now + 1 * 60 * 1000;
        } else {
          // if we haven't seen any horizontal scrolling for a while, assume
          // the user might have plugged in a mousewheel
          if (this._likelyTrackpadUser && now >= this._checkAgainForTrackpad) {
            this._likelyTrackpadUser = false;
          }
        } // don't mess with the horizontal scroll for trackpad users
        // See https://github.com/vector-im/riot-web/issues/10005


        if (this._likelyTrackpadUser) {
          return;
        }

        if (Math.abs(e.deltaX) <= xyThreshold) {
          // we are vertically scrolling.
          // HACK: We increase the amount of scroll to counteract smooth scrolling browsers.
          // Smooth scrolling browsers (Firefox) use the relative area to determine the scroll
          // amount, which means the likely small area of content results in a small amount of
          // movement - not what people expect. We pick arbitrary values for when to apply more
          // scroll, and how much to apply. On Windows 10, Chrome scrolls 100 units whereas
          // Firefox scrolls just 3 due to smooth scrolling.
          const additionalScroll = e.deltaY < 0 ? -50 : 50; // noinspection JSSuspiciousNameCombination

          const val = Math.abs(e.deltaY) < 25 ? e.deltaY + additionalScroll : e.deltaY;
          this._scrollElement.scrollLeft += val * yRetention;
        }
      }
    });
    this._collectScroller = this._collectScroller.bind(this);
    this._collectScrollerComponent = this._collectScrollerComponent.bind(this);
    this.checkOverflow = this.checkOverflow.bind(this);
    this._scrollElement = null;
    this._autoHideScrollbar = null;
    this._likelyTrackpadUser = null;
    this._checkAgainForTrackpad = 0; // ts in milliseconds to recheck this._likelyTrackpadUser

    this.state = {
      leftIndicatorOffset: 0,
      rightIndicatorOffset: 0
    };
  }

  moveToOrigin() {
    if (!this._scrollElement) return;
    this._scrollElement.scrollLeft = 0;
    this._scrollElement.scrollTop = 0;
  }

  _collectScroller(scroller) {
    if (scroller && !this._scrollElement) {
      this._scrollElement = scroller;

      this._scrollElement.addEventListener("scroll", this.checkOverflow);

      this.checkOverflow();
    }
  }

  _collectScrollerComponent(autoHideScrollbar) {
    this._autoHideScrollbar = autoHideScrollbar;
  }

  componentDidUpdate(prevProps) {
    const prevLen = prevProps && prevProps.children && prevProps.children.length || 0;
    const curLen = this.props.children && this.props.children.length || 0; // check overflow only if amount of children changes.
    // if we don't guard here, we end up with an infinite
    // render > componentDidUpdate > checkOverflow > setState > render loop

    if (prevLen !== curLen) {
      this.checkOverflow();
    }
  }

  componentDidMount() {
    this.checkOverflow();
  }

  checkOverflow() {
    const hasTopOverflow = this._scrollElement.scrollTop > 0;
    const hasBottomOverflow = this._scrollElement.scrollHeight > this._scrollElement.scrollTop + this._scrollElement.clientHeight;
    const hasLeftOverflow = this._scrollElement.scrollLeft > 0;
    const hasRightOverflow = this._scrollElement.scrollWidth > this._scrollElement.scrollLeft + this._scrollElement.clientWidth;

    if (hasTopOverflow) {
      this._scrollElement.classList.add("mx_IndicatorScrollbar_topOverflow");
    } else {
      this._scrollElement.classList.remove("mx_IndicatorScrollbar_topOverflow");
    }

    if (hasBottomOverflow) {
      this._scrollElement.classList.add("mx_IndicatorScrollbar_bottomOverflow");
    } else {
      this._scrollElement.classList.remove("mx_IndicatorScrollbar_bottomOverflow");
    }

    if (hasLeftOverflow) {
      this._scrollElement.classList.add("mx_IndicatorScrollbar_leftOverflow");
    } else {
      this._scrollElement.classList.remove("mx_IndicatorScrollbar_leftOverflow");
    }

    if (hasRightOverflow) {
      this._scrollElement.classList.add("mx_IndicatorScrollbar_rightOverflow");
    } else {
      this._scrollElement.classList.remove("mx_IndicatorScrollbar_rightOverflow");
    }

    if (this.props.trackHorizontalOverflow) {
      this.setState({
        // Offset from absolute position of the container
        leftIndicatorOffset: hasLeftOverflow ? "".concat(this._scrollElement.scrollLeft, "px") : '0',
        // Negative because we're coming from the right
        rightIndicatorOffset: hasRightOverflow ? "-".concat(this._scrollElement.scrollLeft, "px") : '0'
      });
    }
  }

  getScrollTop() {
    return this._autoHideScrollbar.getScrollTop();
  }

  componentWillUnmount() {
    if (this._scrollElement) {
      this._scrollElement.removeEventListener("scroll", this.checkOverflow);
    }
  }

  render() {
    const leftIndicatorStyle = {
      left: this.state.leftIndicatorOffset
    };
    const rightIndicatorStyle = {
      right: this.state.rightIndicatorOffset
    };
    const leftOverflowIndicator = this.props.trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_leftOverflowIndicator",
      style: leftIndicatorStyle
    }) : null;
    const rightOverflowIndicator = this.props.trackHorizontalOverflow ? /*#__PURE__*/_react.default.createElement("div", {
      className: "mx_IndicatorScrollbar_rightOverflowIndicator",
      style: rightIndicatorStyle
    }) : null;
    return /*#__PURE__*/_react.default.createElement(_AutoHideScrollbar.default, (0, _extends2.default)({
      ref: this._collectScrollerComponent,
      wrappedRef: this._collectScroller,
      onWheel: this.onMouseWheel
    }, this.props), leftOverflowIndicator, this.props.children, rightOverflowIndicator);
  }

}

exports.default = IndicatorScrollbar;
(0, _defineProperty2.default)(IndicatorScrollbar, "propTypes", {
  // If true, the scrollbar will append mx_IndicatorScrollbar_leftOverflowIndicator
  // and mx_IndicatorScrollbar_rightOverflowIndicator elements to the list for positioning
  // by the parent element.
  trackHorizontalOverflow: _propTypes.default.bool,
  // If true, when the user tries to use their mouse wheel in the component it will
  // scroll horizontally rather than vertically. This should only be used on components
  // with no vertical scroll opportunity.
  verticalScrollsHorizontally: _propTypes.default.bool
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0cnVjdHVyZXMvSW5kaWNhdG9yU2Nyb2xsYmFyLmpzIl0sIm5hbWVzIjpbIkluZGljYXRvclNjcm9sbGJhciIsIlJlYWN0IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImUiLCJ2ZXJ0aWNhbFNjcm9sbHNIb3Jpem9udGFsbHkiLCJfc2Nyb2xsRWxlbWVudCIsInh5VGhyZXNob2xkIiwieVJldGVudGlvbiIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiTWF0aCIsImFicyIsImRlbHRhWCIsIl9saWtlbHlUcmFja3BhZFVzZXIiLCJfY2hlY2tBZ2FpbkZvclRyYWNrcGFkIiwiYWRkaXRpb25hbFNjcm9sbCIsImRlbHRhWSIsInZhbCIsInNjcm9sbExlZnQiLCJfY29sbGVjdFNjcm9sbGVyIiwiYmluZCIsIl9jb2xsZWN0U2Nyb2xsZXJDb21wb25lbnQiLCJjaGVja092ZXJmbG93IiwiX2F1dG9IaWRlU2Nyb2xsYmFyIiwic3RhdGUiLCJsZWZ0SW5kaWNhdG9yT2Zmc2V0IiwicmlnaHRJbmRpY2F0b3JPZmZzZXQiLCJtb3ZlVG9PcmlnaW4iLCJzY3JvbGxUb3AiLCJzY3JvbGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdXRvSGlkZVNjcm9sbGJhciIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZMZW4iLCJjaGlsZHJlbiIsImxlbmd0aCIsImN1ckxlbiIsImNvbXBvbmVudERpZE1vdW50IiwiaGFzVG9wT3ZlcmZsb3ciLCJoYXNCb3R0b21PdmVyZmxvdyIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImhhc0xlZnRPdmVyZmxvdyIsImhhc1JpZ2h0T3ZlcmZsb3ciLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwidHJhY2tIb3Jpem9udGFsT3ZlcmZsb3ciLCJzZXRTdGF0ZSIsImdldFNjcm9sbFRvcCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbmRlciIsImxlZnRJbmRpY2F0b3JTdHlsZSIsImxlZnQiLCJyaWdodEluZGljYXRvclN0eWxlIiwicmlnaHQiLCJsZWZ0T3ZlcmZsb3dJbmRpY2F0b3IiLCJyaWdodE92ZXJmbG93SW5kaWNhdG9yIiwib25Nb3VzZVdoZWVsIiwiUHJvcFR5cGVzIiwiYm9vbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQWdCQTs7QUFDQTs7QUFDQTs7QUFsQkE7Ozs7Ozs7Ozs7Ozs7OztBQW9CZSxNQUFNQSxrQkFBTixTQUFpQ0MsZUFBTUMsU0FBdkMsQ0FBaUQ7QUFhNURDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFRO0FBQ2YsVUFBTUEsS0FBTjtBQURlLHdEQXFHSEMsQ0FBRCxJQUFPO0FBQ2xCLFVBQUksS0FBS0QsS0FBTCxDQUFXRSwyQkFBWCxJQUEwQyxLQUFLQyxjQUFuRCxFQUFtRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxjQUFNQyxXQUFXLEdBQUcsQ0FBcEIsQ0FKK0QsQ0FNL0Q7QUFDQTs7QUFDQSxjQUFNQyxVQUFVLEdBQUcsR0FBbkIsQ0FSK0QsQ0FVL0Q7QUFDQTs7QUFDQSxjQUFNQyxHQUFHLEdBQUcsSUFBSUMsSUFBSixHQUFXQyxPQUFYLEVBQVo7O0FBQ0EsWUFBSUMsSUFBSSxDQUFDQyxHQUFMLENBQVNULENBQUMsQ0FBQ1UsTUFBWCxJQUFxQixDQUF6QixFQUE0QjtBQUN4QixlQUFLQyxtQkFBTCxHQUEyQixJQUEzQjtBQUNBLGVBQUtDLHNCQUFMLEdBQThCUCxHQUFHLEdBQUksSUFBSSxFQUFKLEdBQVMsSUFBOUM7QUFDSCxTQUhELE1BR087QUFDSDtBQUNBO0FBQ0EsY0FBSSxLQUFLTSxtQkFBTCxJQUE0Qk4sR0FBRyxJQUFJLEtBQUtPLHNCQUE1QyxFQUFvRTtBQUNoRSxpQkFBS0QsbUJBQUwsR0FBMkIsS0FBM0I7QUFDSDtBQUNKLFNBdEI4RCxDQXdCL0Q7QUFDQTs7O0FBQ0EsWUFBSSxLQUFLQSxt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QU8sRUFBRSxLQUFLMkM7QUFIVixPQUlDLEtBQUs3RCxLQUpOLEdBTUYyRCxxQkFORSxFQU9GLEtBQUszRCxLQUFMLENBQVdrQyxRQVBULEVBUUYwQixzQkFSRSxDQUFSO0FBVUg7O0FBcEwyRDs7OzhCQUEzQ2hFLGtCLGVBQ0U7QUFDZjtBQUNBO0FBQ0E7QUFDQXFELEVBQUFBLHVCQUF1QixFQUFFYSxtQkFBVUMsSUFKcEI7QUFNZjtBQUNBO0FBQ0E7QUFDQTdELEVBQUFBLDJCQUEyQixFQUFFNEQsbUJBQVVDO0FBVHhCLEMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTggTmV3IFZlY3RvciBMdGRcblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gXCJwcm9wLXR5cGVzXCI7XG5pbXBvcnQgQXV0b0hpZGVTY3JvbGxiYXIgZnJvbSBcIi4vQXV0b0hpZGVTY3JvbGxiYXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5kaWNhdG9yU2Nyb2xsYmFyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgcHJvcFR5cGVzID0ge1xuICAgICAgICAvLyBJZiB0cnVlLCB0aGUgc2Nyb2xsYmFyIHdpbGwgYXBwZW5kIG14X0luZGljYXRvclNjcm9sbGJhcl9sZWZ0T3ZlcmZsb3dJbmRpY2F0b3JcbiAgICAgICAgLy8gYW5kIG14X0luZGljYXRvclNjcm9sbGJhcl9yaWdodE92ZXJmbG93SW5kaWNhdG9yIGVsZW1lbnRzIHRvIHRoZSBsaXN0IGZvciBwb3NpdGlvbmluZ1xuICAgICAgICAvLyBieSB0aGUgcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIHRyYWNrSG9yaXpvbnRhbE92ZXJmbG93OiBQcm9wVHlwZXMuYm9vbCxcblxuICAgICAgICAvLyBJZiB0cnVlLCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIHVzZSB0aGVpciBtb3VzZSB3aGVlbCBpbiB0aGUgY29tcG9uZW50IGl0IHdpbGxcbiAgICAgICAgLy8gc2Nyb2xsIGhvcml6b250YWxseSByYXRoZXIgdGhhbiB2ZXJ0aWNhbGx5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50c1xuICAgICAgICAvLyB3aXRoIG5vIHZlcnRpY2FsIHNjcm9sbCBvcHBvcnR1bml0eS5cbiAgICAgICAgdmVydGljYWxTY3JvbGxzSG9yaXpvbnRhbGx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICB9O1xuXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0U2Nyb2xsZXIgPSB0aGlzLl9jb2xsZWN0U2Nyb2xsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fY29sbGVjdFNjcm9sbGVyQ29tcG9uZW50ID0gdGhpcy5fY29sbGVjdFNjcm9sbGVyQ29tcG9uZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hlY2tPdmVyZmxvdyA9IHRoaXMuY2hlY2tPdmVyZmxvdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXV0b0hpZGVTY3JvbGxiYXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9saWtlbHlUcmFja3BhZFVzZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jaGVja0FnYWluRm9yVHJhY2twYWQgPSAwOyAvLyB0cyBpbiBtaWxsaXNlY29uZHMgdG8gcmVjaGVjayB0aGlzLl9saWtlbHlUcmFja3BhZFVzZXJcblxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbGVmdEluZGljYXRvck9mZnNldDogMCxcbiAgICAgICAgICAgIHJpZ2h0SW5kaWNhdG9yT2Zmc2V0OiAwLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG1vdmVUb09yaWdpbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JvbGxFbGVtZW50KSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgIH1cblxuICAgIF9jb2xsZWN0U2Nyb2xsZXIoc2Nyb2xsZXIpIHtcbiAgICAgICAgaWYgKHNjcm9sbGVyICYmICF0aGlzLl9zY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gc2Nyb2xsZXI7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5jaGVja092ZXJmbG93KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tPdmVyZmxvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NvbGxlY3RTY3JvbGxlckNvbXBvbmVudChhdXRvSGlkZVNjcm9sbGJhcikge1xuICAgICAgICB0aGlzLl9hdXRvSGlkZVNjcm9sbGJhciA9IGF1dG9IaWRlU2Nyb2xsYmFyO1xuICAgIH1cblxuXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCBwcmV2TGVuID0gcHJldlByb3BzICYmIHByZXZQcm9wcy5jaGlsZHJlbiAmJiBwcmV2UHJvcHMuY2hpbGRyZW4ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGNvbnN0IGN1ckxlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGggfHwgMDtcbiAgICAgICAgLy8gY2hlY2sgb3ZlcmZsb3cgb25seSBpZiBhbW91bnQgb2YgY2hpbGRyZW4gY2hhbmdlcy5cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgZ3VhcmQgaGVyZSwgd2UgZW5kIHVwIHdpdGggYW4gaW5maW5pdGVcbiAgICAgICAgLy8gcmVuZGVyID4gY29tcG9uZW50RGlkVXBkYXRlID4gY2hlY2tPdmVyZmxvdyA+IHNldFN0YXRlID4gcmVuZGVyIGxvb3BcbiAgICAgICAgaWYgKHByZXZMZW4gIT09IGN1ckxlbikge1xuICAgICAgICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jaGVja092ZXJmbG93KCk7XG4gICAgfVxuXG4gICAgY2hlY2tPdmVyZmxvdygpIHtcbiAgICAgICAgY29uc3QgaGFzVG9wT3ZlcmZsb3cgPSB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbFRvcCA+IDA7XG4gICAgICAgIGNvbnN0IGhhc0JvdHRvbU92ZXJmbG93ID0gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgPlxuICAgICAgICAgICAgKHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wICsgdGhpcy5fc2Nyb2xsRWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICBjb25zdCBoYXNMZWZ0T3ZlcmZsb3cgPSB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgPiAwO1xuICAgICAgICBjb25zdCBoYXNSaWdodE92ZXJmbG93ID0gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxXaWR0aCA+XG4gICAgICAgICAgICAodGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxMZWZ0ICsgdGhpcy5fc2Nyb2xsRWxlbWVudC5jbGllbnRXaWR0aCk7XG5cbiAgICAgICAgaWYgKGhhc1RvcE92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfdG9wT3ZlcmZsb3dcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfdG9wT3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0JvdHRvbU92ZXJmbG93KSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfYm90dG9tT3ZlcmZsb3dcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJteF9JbmRpY2F0b3JTY3JvbGxiYXJfYm90dG9tT3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xlZnRPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX2xlZnRPdmVyZmxvd1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcIm14X0luZGljYXRvclNjcm9sbGJhcl9sZWZ0T3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1JpZ2h0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm14X0luZGljYXRvclNjcm9sbGJhcl9yaWdodE92ZXJmbG93XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3JpZ2h0T3ZlcmZsb3dcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wcm9wcy50cmFja0hvcml6b250YWxPdmVyZmxvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgLy8gT2Zmc2V0IGZyb20gYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIGxlZnRJbmRpY2F0b3JPZmZzZXQ6IGhhc0xlZnRPdmVyZmxvdyA/IGAke3RoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdH1weGAgOiAnMCcsXG5cbiAgICAgICAgICAgICAgICAvLyBOZWdhdGl2ZSBiZWNhdXNlIHdlJ3JlIGNvbWluZyBmcm9tIHRoZSByaWdodFxuICAgICAgICAgICAgICAgIHJpZ2h0SW5kaWNhdG9yT2Zmc2V0OiBoYXNSaWdodE92ZXJmbG93ID8gYC0ke3RoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsTGVmdH1weGAgOiAnMCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9IaWRlU2Nyb2xsYmFyLmdldFNjcm9sbFRvcCgpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMuY2hlY2tPdmVyZmxvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk1vdXNlV2hlZWwgPSAoZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52ZXJ0aWNhbFNjcm9sbHNIb3Jpem9udGFsbHkgJiYgdGhpcy5fc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgLy8geHlUaHJlc2hvbGQgaXMgdGhlIGFtb3VudCBvZiBob3Jpem9udGFsIG1vdGlvbiByZXF1aXJlZCBmb3IgdGhlIGNvbXBvbmVudCB0b1xuICAgICAgICAgICAgLy8gaWdub3JlIHRoZSB2ZXJ0aWNhbCBkZWx0YSBpbiBhIHNjcm9sbC4gVXNlZCB0byBzdG9wIHRyYWNrcGFkcyBmcm9tIGFjdGluZyBpblxuICAgICAgICAgICAgLy8gc3RyYW5nZSB3YXlzLiBTaG91bGQgYmUgcG9zaXRpdmUuXG4gICAgICAgICAgICBjb25zdCB4eVRocmVzaG9sZCA9IDA7XG5cbiAgICAgICAgICAgIC8vIHlSZXRlbnRpb24gaXMgdGhlIGZhY3RvciBtdWx0aXBsaWVkIGJ5IHRoZSB2ZXJ0aWNhbCBkZWx0YSB0byB0cnkgYW5kIHJlZHVjZVxuICAgICAgICAgICAgLy8gdGhlIGhhcnNobmVzcyBvZiB0aGUgc2Nyb2xsIGJlaGF2aW91ci4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICAgICAgY29uc3QgeVJldGVudGlvbiA9IDEuMDtcblxuICAgICAgICAgICAgLy8gd2hlbmV2ZXIgd2Ugc2VlIGhvcml6b250YWwgc2Nyb2xsaW5nLCBhc3N1bWUgdGhlIHVzZXIgaXMgb24gYSB0cmFja3BhZFxuICAgICAgICAgICAgLy8gZm9yIGF0IGxlYXN0IHRoZSBuZXh0IDEgbWludXRlLlxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZS5kZWx0YVgpID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpa2VseVRyYWNrcGFkVXNlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tBZ2FpbkZvclRyYWNrcGFkID0gbm93ICsgKDEgKiA2MCAqIDEwMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHNlZW4gYW55IGhvcml6b250YWwgc2Nyb2xsaW5nIGZvciBhIHdoaWxlLCBhc3N1bWVcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXNlciBtaWdodCBoYXZlIHBsdWdnZWQgaW4gYSBtb3VzZXdoZWVsXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xpa2VseVRyYWNrcGFkVXNlciAmJiBub3cgPj0gdGhpcy5fY2hlY2tBZ2FpbkZvclRyYWNrcGFkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpa2VseVRyYWNrcGFkVXNlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZG9uJ3QgbWVzcyB3aXRoIHRoZSBob3Jpem9udGFsIHNjcm9sbCBmb3IgdHJhY2twYWQgdXNlcnNcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL3Jpb3Qtd2ViL2lzc3Vlcy8xMDAwNVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpa2VseVRyYWNrcGFkVXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGUuZGVsdGFYKSA8PSB4eVRocmVzaG9sZCkgeyAvLyB3ZSBhcmUgdmVydGljYWxseSBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgLy8gSEFDSzogV2UgaW5jcmVhc2UgdGhlIGFtb3VudCBvZiBzY3JvbGwgdG8gY291bnRlcmFjdCBzbW9vdGggc2Nyb2xsaW5nIGJyb3dzZXJzLlxuICAgICAgICAgICAgICAgIC8vIFNtb290aCBzY3JvbGxpbmcgYnJvd3NlcnMgKEZpcmVmb3gpIHVzZSB0aGUgcmVsYXRpdmUgYXJlYSB0byBkZXRlcm1pbmUgdGhlIHNjcm9sbFxuICAgICAgICAgICAgICAgIC8vIGFtb3VudCwgd2hpY2ggbWVhbnMgdGhlIGxpa2VseSBzbWFsbCBhcmVhIG9mIGNvbnRlbnQgcmVzdWx0cyBpbiBhIHNtYWxsIGFtb3VudCBvZlxuICAgICAgICAgICAgICAgIC8vIG1vdmVtZW50IC0gbm90IHdoYXQgcGVvcGxlIGV4cGVjdC4gV2UgcGljayBhcmJpdHJhcnkgdmFsdWVzIGZvciB3aGVuIHRvIGFwcGx5IG1vcmVcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGwsIGFuZCBob3cgbXVjaCB0byBhcHBseS4gT24gV2luZG93cyAxMCwgQ2hyb21lIHNjcm9sbHMgMTAwIHVuaXRzIHdoZXJlYXNcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IHNjcm9sbHMganVzdCAzIGR1ZSB0byBzbW9vdGggc2Nyb2xsaW5nLlxuXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbFNjcm9sbCA9IGUuZGVsdGFZIDwgMCA/IC01MCA6IDUwO1xuXG4gICAgICAgICAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTU3VzcGljaW91c05hbWVDb21iaW5hdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IE1hdGguYWJzKGUuZGVsdGFZKSA8IDI1ID8gKGUuZGVsdGFZICsgYWRkaXRpb25hbFNjcm9sbCkgOiBlLmRlbHRhWTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbExlZnQgKz0gdmFsICogeVJldGVudGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IGxlZnRJbmRpY2F0b3JTdHlsZSA9IHtsZWZ0OiB0aGlzLnN0YXRlLmxlZnRJbmRpY2F0b3JPZmZzZXR9O1xuICAgICAgICBjb25zdCByaWdodEluZGljYXRvclN0eWxlID0ge3JpZ2h0OiB0aGlzLnN0YXRlLnJpZ2h0SW5kaWNhdG9yT2Zmc2V0fTtcbiAgICAgICAgY29uc3QgbGVmdE92ZXJmbG93SW5kaWNhdG9yID0gdGhpcy5wcm9wcy50cmFja0hvcml6b250YWxPdmVyZmxvd1xuICAgICAgICAgICAgPyA8ZGl2IGNsYXNzTmFtZT1cIm14X0luZGljYXRvclNjcm9sbGJhcl9sZWZ0T3ZlcmZsb3dJbmRpY2F0b3JcIiBzdHlsZT17bGVmdEluZGljYXRvclN0eWxlfSAvPiA6IG51bGw7XG4gICAgICAgIGNvbnN0IHJpZ2h0T3ZlcmZsb3dJbmRpY2F0b3IgPSB0aGlzLnByb3BzLnRyYWNrSG9yaXpvbnRhbE92ZXJmbG93XG4gICAgICAgICAgICA/IDxkaXYgY2xhc3NOYW1lPVwibXhfSW5kaWNhdG9yU2Nyb2xsYmFyX3JpZ2h0T3ZlcmZsb3dJbmRpY2F0b3JcIiBzdHlsZT17cmlnaHRJbmRpY2F0b3JTdHlsZX0gLz4gOiBudWxsO1xuXG4gICAgICAgIHJldHVybiAoPEF1dG9IaWRlU2Nyb2xsYmFyXG4gICAgICAgICAgICByZWY9e3RoaXMuX2NvbGxlY3RTY3JvbGxlckNvbXBvbmVudH1cbiAgICAgICAgICAgIHdyYXBwZWRSZWY9e3RoaXMuX2NvbGxlY3RTY3JvbGxlcn1cbiAgICAgICAgICAgIG9uV2hlZWw9e3RoaXMub25Nb3VzZVdoZWVsfVxuICAgICAgICAgICAgey4uLiB0aGlzLnByb3BzfVxuICAgICAgICA+XG4gICAgICAgICAgICB7IGxlZnRPdmVyZmxvd0luZGljYXRvciB9XG4gICAgICAgICAgICB7IHRoaXMucHJvcHMuY2hpbGRyZW4gfVxuICAgICAgICAgICAgeyByaWdodE92ZXJmbG93SW5kaWNhdG9yIH1cbiAgICAgICAgPC9BdXRvSGlkZVNjcm9sbGJhcj4pO1xuICAgIH1cbn1cbiJdfQ==