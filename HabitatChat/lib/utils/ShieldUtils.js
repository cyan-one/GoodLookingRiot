"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shieldStatusForRoom = shieldStatusForRoom;

var _DMRoomMap = _interopRequireDefault(require("./DMRoomMap"));

async function shieldStatusForRoom(client
/*: Client*/
, room
/*: Room*/
)
/*: Promise<string>*/
{
  const members = (await room.getEncryptionTargetMembers()).map(({
    userId
  }) => userId);
  const inDMMap = !!_DMRoomMap.default.shared().getUserIdForRoomId(room.roomId);
  const verified
  /*: string[]*/
  = [];
  const unverified
  /*: string[]*/
  = [];
  members.filter(userId => userId !== client.getUserId()).forEach(userId => {
    (client.checkUserTrust(userId).isCrossSigningVerified() ? verified : unverified).push(userId);
  });
  /* Alarm if any unverified users were verified before. */

  for (const userId of unverified) {
    if (client.checkUserTrust(userId).wasCrossSigningVerified()) {
      return "warning";
    }
  }
  /* Check all verified user devices. */

  /* Don't alarm if no other users are verified  */


  const includeUser = verified.length > 0 && // Don't alarm for self in rooms where nobody else is verified
  !inDMMap && // Don't alarm for self in DMs with other users
  members.length !== 2 || // Don't alarm for self in 1:1 chats with other users
  members.length === 1; // Do alarm for self if we're alone in a room

  const targets = includeUser ? [...verified, client.getUserId()] : verified;

  for (const userId of targets) {
    const devices = client.getStoredDevicesForUser(userId);
    const anyDeviceNotVerified = devices.some(({
      deviceId
    }) => {
      return !client.checkDeviceTrust(userId, deviceId).isVerified();
    });

    if (anyDeviceNotVerified) {
      return "warning";
    }
  }

  return unverified.length === 0 ? "verified" : "normal";
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9TaGllbGRVdGlscy50cyJdLCJuYW1lcyI6WyJzaGllbGRTdGF0dXNGb3JSb29tIiwiY2xpZW50Iiwicm9vbSIsIm1lbWJlcnMiLCJnZXRFbmNyeXB0aW9uVGFyZ2V0TWVtYmVycyIsIm1hcCIsInVzZXJJZCIsImluRE1NYXAiLCJETVJvb21NYXAiLCJzaGFyZWQiLCJnZXRVc2VySWRGb3JSb29tSWQiLCJyb29tSWQiLCJ2ZXJpZmllZCIsInVudmVyaWZpZWQiLCJmaWx0ZXIiLCJnZXRVc2VySWQiLCJmb3JFYWNoIiwiY2hlY2tVc2VyVHJ1c3QiLCJpc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkIiwicHVzaCIsIndhc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkIiwiaW5jbHVkZVVzZXIiLCJsZW5ndGgiLCJ0YXJnZXRzIiwiZGV2aWNlcyIsImdldFN0b3JlZERldmljZXNGb3JVc2VyIiwiYW55RGV2aWNlTm90VmVyaWZpZWQiLCJzb21lIiwiZGV2aWNlSWQiLCJjaGVja0RldmljZVRydXN0IiwiaXNWZXJpZmllZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBb0JPLGVBQWVBLG1CQUFmLENBQW1DQztBQUFuQztBQUFBLEVBQW1EQztBQUFuRDtBQUFBO0FBQUE7QUFBZ0Y7QUFDbkYsUUFBTUMsT0FBTyxHQUFHLENBQUMsTUFBTUQsSUFBSSxDQUFDRSwwQkFBTCxFQUFQLEVBQTBDQyxHQUExQyxDQUE4QyxDQUFDO0FBQUNDLElBQUFBO0FBQUQsR0FBRCxLQUFjQSxNQUE1RCxDQUFoQjtBQUNBLFFBQU1DLE9BQU8sR0FBRyxDQUFDLENBQUNDLG1CQUFVQyxNQUFWLEdBQW1CQyxrQkFBbkIsQ0FBc0NSLElBQUksQ0FBQ1MsTUFBM0MsQ0FBbEI7QUFFQSxRQUFNQztBQUFrQjtBQUFBLElBQUcsRUFBM0I7QUFDQSxRQUFNQztBQUFvQjtBQUFBLElBQUcsRUFBN0I7QUFDQVYsRUFBQUEsT0FBTyxDQUFDVyxNQUFSLENBQWdCUixNQUFELElBQVlBLE1BQU0sS0FBS0wsTUFBTSxDQUFDYyxTQUFQLEVBQXRDLEVBQ0tDLE9BREwsQ0FDY1YsTUFBRCxJQUFZO0FBQ2pCLEtBQUNMLE1BQU0sQ0FBQ2dCLGNBQVAsQ0FBc0JYLE1BQXRCLEVBQThCWSxzQkFBOUIsS0FDRE4sUUFEQyxHQUNVQyxVQURYLEVBQ3VCTSxJQUR2QixDQUM0QmIsTUFENUI7QUFFSCxHQUpMO0FBTUE7O0FBQ0EsT0FBSyxNQUFNQSxNQUFYLElBQXFCTyxVQUFyQixFQUFpQztBQUM3QixRQUFJWixNQUFNLENBQUNnQixjQUFQLENBQXNCWCxNQUF0QixFQUE4QmMsdUJBQTlCLEVBQUosRUFBNkQ7QUFDekQsYUFBTyxTQUFQO0FBQ0g7QUFDSjtBQUVEOztBQUNBOzs7QUFDQSxRQUFNQyxXQUFXLEdBQUlULFFBQVEsQ0FBQ1UsTUFBVCxHQUFrQixDQUFuQixJQUE0QjtBQUM1QixHQUFDZixPQURELElBQzRCO0FBQzNCSixFQUFBQSxPQUFPLENBQUNtQixNQUFSLEtBQW1CLENBRnBCLElBRTRCO0FBQzNCbkIsRUFBQUEsT0FBTyxDQUFDbUIsTUFBUixLQUFtQixDQUh4QyxDQXJCbUYsQ0F3Qm5DOztBQUNoRCxRQUFNQyxPQUFPLEdBQUdGLFdBQVcsR0FBRyxDQUFDLEdBQUdULFFBQUosRUFBY1gsTUFBTSxDQUFDYyxTQUFQLEVBQWQsQ0FBSCxHQUF1Q0gsUUFBbEU7O0FBQ0EsT0FBSyxNQUFNTixNQUFYLElBQXFCaUIsT0FBckIsRUFBOEI7QUFDMUIsVUFBTUMsT0FBTyxHQUFHdkIsTUFBTSxDQUFDd0IsdUJBQVAsQ0FBK0JuQixNQUEvQixDQUFoQjtBQUNBLFVBQU1vQixvQkFBb0IsR0FBR0YsT0FBTyxDQUFDRyxJQUFSLENBQWEsQ0FBQztBQUFDQyxNQUFBQTtBQUFELEtBQUQsS0FBZ0I7QUFDdEQsYUFBTyxDQUFDM0IsTUFBTSxDQUFDNEIsZ0JBQVAsQ0FBd0J2QixNQUF4QixFQUFnQ3NCLFFBQWhDLEVBQTBDRSxVQUExQyxFQUFSO0FBQ0gsS0FGNEIsQ0FBN0I7O0FBR0EsUUFBSUosb0JBQUosRUFBMEI7QUFDdEIsYUFBTyxTQUFQO0FBQ0g7QUFDSjs7QUFFRCxTQUFPYixVQUFVLENBQUNTLE1BQVgsS0FBc0IsQ0FBdEIsR0FBMEIsVUFBMUIsR0FBdUMsUUFBOUM7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBETVJvb21NYXAgZnJvbSAnLi9ETVJvb21NYXAnO1xuXG4vKiBGb3Igbm93LCBhIGN1dC1kb3duIHR5cGUgc3BlYyBmb3IgdGhlIGNsaWVudCAqL1xuaW50ZXJmYWNlIENsaWVudCB7XG4gICAgZ2V0VXNlcklkOiAoKSA9PiBzdHJpbmc7XG4gICAgY2hlY2tVc2VyVHJ1c3Q6ICh1c2VySWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkOiAoKSA9PiBib29sZWFuXG4gICAgICAgIHdhc0Nyb3NzU2lnbmluZ1ZlcmlmaWVkOiAoKSA9PiBib29sZWFuXG4gICAgfTtcbiAgICBnZXRTdG9yZWREZXZpY2VzRm9yVXNlcjogKHVzZXJJZDogc3RyaW5nKSA9PiBbeyBkZXZpY2VJZDogc3RyaW5nIH1dO1xuICAgIGNoZWNrRGV2aWNlVHJ1c3Q6ICh1c2VySWQ6IHN0cmluZywgZGV2aWNlSWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBpc1ZlcmlmaWVkOiAoKSA9PiBib29sZWFuXG4gICAgfVxufVxuXG5pbnRlcmZhY2UgUm9vbSB7XG4gICAgZ2V0RW5jcnlwdGlvblRhcmdldE1lbWJlcnM6ICgpID0+IFByb21pc2U8W3t1c2VySWQ6IHN0cmluZ31dPjtcbiAgICByb29tSWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNoaWVsZFN0YXR1c0ZvclJvb20oY2xpZW50OiBDbGllbnQsIHJvb206IFJvb20pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1lbWJlcnMgPSAoYXdhaXQgcm9vbS5nZXRFbmNyeXB0aW9uVGFyZ2V0TWVtYmVycygpKS5tYXAoKHt1c2VySWR9KSA9PiB1c2VySWQpO1xuICAgIGNvbnN0IGluRE1NYXAgPSAhIURNUm9vbU1hcC5zaGFyZWQoKS5nZXRVc2VySWRGb3JSb29tSWQocm9vbS5yb29tSWQpO1xuXG4gICAgY29uc3QgdmVyaWZpZWQ6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdW52ZXJpZmllZDogc3RyaW5nW10gPSBbXTtcbiAgICBtZW1iZXJzLmZpbHRlcigodXNlcklkKSA9PiB1c2VySWQgIT09IGNsaWVudC5nZXRVc2VySWQoKSlcbiAgICAgICAgLmZvckVhY2goKHVzZXJJZCkgPT4ge1xuICAgICAgICAgICAgKGNsaWVudC5jaGVja1VzZXJUcnVzdCh1c2VySWQpLmlzQ3Jvc3NTaWduaW5nVmVyaWZpZWQoKSA/XG4gICAgICAgICAgICB2ZXJpZmllZCA6IHVudmVyaWZpZWQpLnB1c2godXNlcklkKTtcbiAgICAgICAgfSk7XG5cbiAgICAvKiBBbGFybSBpZiBhbnkgdW52ZXJpZmllZCB1c2VycyB3ZXJlIHZlcmlmaWVkIGJlZm9yZS4gKi9cbiAgICBmb3IgKGNvbnN0IHVzZXJJZCBvZiB1bnZlcmlmaWVkKSB7XG4gICAgICAgIGlmIChjbGllbnQuY2hlY2tVc2VyVHJ1c3QodXNlcklkKS53YXNDcm9zc1NpZ25pbmdWZXJpZmllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDaGVjayBhbGwgdmVyaWZpZWQgdXNlciBkZXZpY2VzLiAqL1xuICAgIC8qIERvbid0IGFsYXJtIGlmIG5vIG90aGVyIHVzZXJzIGFyZSB2ZXJpZmllZCAgKi9cbiAgICBjb25zdCBpbmNsdWRlVXNlciA9ICh2ZXJpZmllZC5sZW5ndGggPiAwKSAmJiAgICAvLyBEb24ndCBhbGFybSBmb3Igc2VsZiBpbiByb29tcyB3aGVyZSBub2JvZHkgZWxzZSBpcyB2ZXJpZmllZFxuICAgICAgICAgICAgICAgICAgICAgICAgIWluRE1NYXAgJiYgICAgICAgICAgICAgICAgIC8vIERvbid0IGFsYXJtIGZvciBzZWxmIGluIERNcyB3aXRoIG90aGVyIHVzZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAobWVtYmVycy5sZW5ndGggIT09IDIpIHx8ICAgLy8gRG9uJ3QgYWxhcm0gZm9yIHNlbGYgaW4gMToxIGNoYXRzIHdpdGggb3RoZXIgdXNlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIChtZW1iZXJzLmxlbmd0aCA9PT0gMSk7ICAgICAvLyBEbyBhbGFybSBmb3Igc2VsZiBpZiB3ZSdyZSBhbG9uZSBpbiBhIHJvb21cbiAgICBjb25zdCB0YXJnZXRzID0gaW5jbHVkZVVzZXIgPyBbLi4udmVyaWZpZWQsIGNsaWVudC5nZXRVc2VySWQoKV0gOiB2ZXJpZmllZDtcbiAgICBmb3IgKGNvbnN0IHVzZXJJZCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIGNvbnN0IGRldmljZXMgPSBjbGllbnQuZ2V0U3RvcmVkRGV2aWNlc0ZvclVzZXIodXNlcklkKTtcbiAgICAgICAgY29uc3QgYW55RGV2aWNlTm90VmVyaWZpZWQgPSBkZXZpY2VzLnNvbWUoKHtkZXZpY2VJZH0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhY2xpZW50LmNoZWNrRGV2aWNlVHJ1c3QodXNlcklkLCBkZXZpY2VJZCkuaXNWZXJpZmllZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFueURldmljZU5vdFZlcmlmaWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW52ZXJpZmllZC5sZW5ndGggPT09IDAgPyBcInZlcmlmaWVkXCIgOiBcIm5vcm1hbFwiO1xufVxuIl19