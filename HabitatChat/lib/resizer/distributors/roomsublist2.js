"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Distributor = exports.Layout = void 0;

var _fixed = _interopRequireDefault(require("./fixed"));

/*
Copyright 2019 New Vector Ltd

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function clamp(height, min, max) {
  if (height > max) return max;
  if (height < min) return min;
  return height;
}

class Layout {
  constructor(applyHeight, initialSizes, collapsedState, options) {
    // callback to set height of section
    this._applyHeight = applyHeight; // list of {id, count} objects,
    // determines sections and order of them

    this._sections = []; // stores collapsed by id

    this._collapsedState = Object.assign({}, collapsedState); // total available height to the layout
    // (including resize handles, ...)

    this._availableHeight = 0; // heights stored by section section id

    this._sectionHeights = Object.assign({}, initialSizes); // in-progress heights, while dragging. Committed on mouse-up.

    this._heights = []; // use while manually resizing to cancel
    // the resize for a given mouse position
    // when the previous resize made the layout
    // constrained

    this._clampedOffset = 0; // used while manually resizing, to clear
    // _clampedOffset when the direction of resizing changes

    this._lastOffset = 0;
    this._allowWhitespace = options && options.allowWhitespace;
    this._handleHeight = options && options.handleHeight || 0;
  }

  setAvailableHeight(newSize) {
    this._availableHeight = newSize; // needs more work

    this._applyNewSize();
  }

  expandSection(id, height) {
    this._collapsedState[id] = false;

    this._applyNewSize();

    this.openHandle(id).setHeight(height).finish();
  }

  collapseSection(id) {
    this._collapsedState[id] = true;

    this._applyNewSize();
  }

  update(sections, availableHeight, force = false) {
    let heightChanged = false;

    if (Number.isFinite(availableHeight) && availableHeight !== this._availableHeight) {
      heightChanged = true;
      this._availableHeight = availableHeight;
    }

    const sectionsChanged = sections.length !== this._sections.length || sections.some((a, i) => {
      const b = this._sections[i];
      return a.id !== b.id || a.count !== b.count;
    });

    if (!heightChanged && !sectionsChanged && !force) {
      return;
    }

    this._sections = sections;

    const totalHeight = this._getAvailableHeight();

    const defaultHeight = Math.floor(totalHeight / this._sections.length);

    this._sections.forEach((section, i) => {
      if (!this._sectionHeights[section.id]) {
        this._sectionHeights[section.id] = clamp(defaultHeight, this._getMinHeight(i), this._getMaxHeight(i));
      }
    });

    this._applyNewSize();
  }

  openHandle(id) {
    const index = this._getSectionIndex(id);

    return new Handle(this, index, this._sectionHeights[id]);
  }

  _getAvailableHeight() {
    const nonCollapsedSectionCount = this._sections.reduce((count, section) => {
      const collapsed = this._collapsedState[section.id];
      return count + (collapsed ? 0 : 1);
    }, 0);

    return this._availableHeight - (nonCollapsedSectionCount - 1) * this._handleHeight;
  }

  _applyNewSize() {
    const newHeight = this._getAvailableHeight();

    const currHeight = this._sections.reduce((sum, section) => {
      return sum + this._sectionHeights[section.id];
    }, 0);

    const offset = newHeight - currHeight;
    this._heights = this._sections.map(section => this._sectionHeights[section.id]);

    const sections = this._sections.map((_, i) => i);

    this._applyOverflow(-offset, sections, true);

    this._applyHeights();

    this._commitHeights();
  }

  _getSectionIndex(id) {
    return this._sections.findIndex(s => s.id === id);
  }

  _getMaxHeight(i) {
    const section = this._sections[i];
    const collapsed = this._collapsedState[section.id];

    if (collapsed) {
      return this._sectionHeight(0);
    } else if (!this._allowWhitespace) {
      return this._sectionHeight(section.count);
    } else {
      return 100000;
    }
  }

  _sectionHeight(count) {
    return 36 + (count === 0 ? 0 : 4 + count * 34);
  }

  _getMinHeight(i) {
    const section = this._sections[i];
    const collapsed = this._collapsedState[section.id];
    const maxItems = collapsed ? 0 : 1;
    return this._sectionHeight(Math.min(section.count, maxItems));
  }

  _applyOverflow(overflow, sections, blend) {
    // take the given overflow amount, and applies it to the given sections.
    // calls itself recursively until it has distributed all the overflow
    // or run out of unclamped sections.
    const unclampedSections = [];
    let overflowPerSection = blend ? overflow / sections.length : overflow;

    for (const i of sections) {
      const newHeight = clamp(this._heights[i] - overflowPerSection, this._getMinHeight(i), this._getMaxHeight(i));

      if (newHeight == this._heights[i] - overflowPerSection) {
        unclampedSections.push(i);
      } // when section is growing, overflow increases?
      // 100 -= 200 - 300
      // 100 -= -100
      // 200


      overflow -= this._heights[i] - newHeight;
      this._heights[i] = newHeight;

      if (!blend) {
        overflowPerSection = overflow;
        if (Math.abs(overflow) < 1.0) break;
      }
    }

    if (Math.abs(overflow) > 1.0 && unclampedSections.length > 0) {
      // we weren't able to distribute all the overflow so recurse and try again
      overflow = this._applyOverflow(overflow, unclampedSections, blend);
    }

    return overflow;
  }

  _rebalanceAbove(sectionIndex, overflowAbove) {
    if (Math.abs(overflowAbove) > 1.0) {
      const sections = [];

      for (let i = sectionIndex - 1; i >= 0; i--) {
        sections.push(i);
      }

      overflowAbove = this._applyOverflow(overflowAbove, sections);
    }

    return overflowAbove;
  }

  _rebalanceBelow(sectionIndex, overflowBelow) {
    if (Math.abs(overflowBelow) > 1.0) {
      const sections = [];

      for (let i = sectionIndex + 1; i < this._sections.length; i++) {
        sections.push(i);
      }

      overflowBelow = this._applyOverflow(overflowBelow, sections);
    }

    return overflowBelow;
  } // @param offset the amount the sectionIndex is moved from what is stored in _sectionHeights, positive if downwards
  // if we're constrained, return the offset we should be constrained at.


  _relayout(sectionIndex = 0, offset = 0, constrained = false) {
    this._heights = this._sections.map(section => this._sectionHeights[section.id]); // are these the amounts the items above/below shrank/grew and need to be relayouted?

    let overflowAbove;
    let overflowBelow;

    const maxHeight = this._getMaxHeight(sectionIndex);

    const minHeight = this._getMinHeight(sectionIndex); // new height > max ?


    if (this._heights[sectionIndex] + offset > maxHeight) {
      // we're pulling downwards and constrained
      // overflowAbove = minus how much are we above max height
      overflowAbove = maxHeight - this._heights[sectionIndex] - offset;
      overflowBelow = offset;
    } else if (this._heights[sectionIndex] + offset < minHeight) {
      // new height < min?
      // we're pulling upwards and constrained
      overflowAbove = minHeight - this._heights[sectionIndex] - offset;
      overflowBelow = offset;
    } else {
      overflowAbove = 0;
      overflowBelow = offset;
    }

    this._heights[sectionIndex] = clamp(this._heights[sectionIndex] + offset, minHeight, maxHeight); // these are reassigned the amount of overflow that could not be rebalanced
    // meaning we dragged the handle too far and it can't follow the cursor anymore

    overflowAbove = this._rebalanceAbove(sectionIndex, overflowAbove);
    overflowBelow = this._rebalanceBelow(sectionIndex, overflowBelow);

    if (!constrained) {
      // to avoid risk of infinite recursion
      // clamp to avoid overflowing or underflowing the page
      if (Math.abs(overflowAbove) > 1.0) {
        // here we do the layout again with offset - the amount of space we took too much
        this._relayout(sectionIndex, offset + overflowAbove, true);

        return offset + overflowAbove;
      }

      if (Math.abs(overflowBelow) > 1.0) {
        // here we do the layout again with offset - the amount of space we took too much
        this._relayout(sectionIndex, offset - overflowBelow, true);

        return offset - overflowBelow;
      }
    }

    this._applyHeights();

    return undefined;
  }

  _applyHeights() {
    // apply the heights
    for (let i = 0; i < this._sections.length; i++) {
      const section = this._sections[i];

      this._applyHeight(section.id, this._heights[i]);
    }
  }

  _commitHeights() {
    this._sections.forEach((section, i) => {
      this._sectionHeights[section.id] = this._heights[i];
    });
  }

  _setUncommittedSectionHeight(sectionIndex, offset) {
    if (Math.sign(offset) != Math.sign(this._lastOffset)) {
      this._clampedOffset = undefined;
    }

    if (this._clampedOffset !== undefined) {
      if (offset < 0 && offset < this._clampedOffset) {
        return;
      }

      if (offset > 0 && offset > this._clampedOffset) {
        return;
      }
    }

    this._clampedOffset = this._relayout(sectionIndex, offset);
    this._lastOffset = offset;
  }

}

exports.Layout = Layout;

class Handle {
  constructor(layout, sectionIndex, height) {
    this._layout = layout;
    this._sectionIndex = sectionIndex;
    this._initialHeight = height;
  }

  setHeight(height) {
    this._layout._setUncommittedSectionHeight(this._sectionIndex, height - this._initialHeight);

    return this;
  }

  finish() {
    this._layout._commitHeights();

    return this;
  }

}

class Distributor extends _fixed.default {
  constructor(item, cfg) {
    super(item);
    this._handle = cfg.getLayout().openHandle(item.id);
  }

  finish() {
    this._handle.finish();
  }

  resize(height) {
    this._handle.setHeight(height);
  }

}

exports.Distributor = Distributor;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yZXNpemVyL2Rpc3RyaWJ1dG9ycy9yb29tc3VibGlzdDIuanMiXSwibmFtZXMiOlsiY2xhbXAiLCJoZWlnaHQiLCJtaW4iLCJtYXgiLCJMYXlvdXQiLCJjb25zdHJ1Y3RvciIsImFwcGx5SGVpZ2h0IiwiaW5pdGlhbFNpemVzIiwiY29sbGFwc2VkU3RhdGUiLCJvcHRpb25zIiwiX2FwcGx5SGVpZ2h0IiwiX3NlY3Rpb25zIiwiX2NvbGxhcHNlZFN0YXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiX2F2YWlsYWJsZUhlaWdodCIsIl9zZWN0aW9uSGVpZ2h0cyIsIl9oZWlnaHRzIiwiX2NsYW1wZWRPZmZzZXQiLCJfbGFzdE9mZnNldCIsIl9hbGxvd1doaXRlc3BhY2UiLCJhbGxvd1doaXRlc3BhY2UiLCJfaGFuZGxlSGVpZ2h0IiwiaGFuZGxlSGVpZ2h0Iiwic2V0QXZhaWxhYmxlSGVpZ2h0IiwibmV3U2l6ZSIsIl9hcHBseU5ld1NpemUiLCJleHBhbmRTZWN0aW9uIiwiaWQiLCJvcGVuSGFuZGxlIiwic2V0SGVpZ2h0IiwiZmluaXNoIiwiY29sbGFwc2VTZWN0aW9uIiwidXBkYXRlIiwic2VjdGlvbnMiLCJhdmFpbGFibGVIZWlnaHQiLCJmb3JjZSIsImhlaWdodENoYW5nZWQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInNlY3Rpb25zQ2hhbmdlZCIsImxlbmd0aCIsInNvbWUiLCJhIiwiaSIsImIiLCJjb3VudCIsInRvdGFsSGVpZ2h0IiwiX2dldEF2YWlsYWJsZUhlaWdodCIsImRlZmF1bHRIZWlnaHQiLCJNYXRoIiwiZmxvb3IiLCJmb3JFYWNoIiwic2VjdGlvbiIsIl9nZXRNaW5IZWlnaHQiLCJfZ2V0TWF4SGVpZ2h0IiwiaW5kZXgiLCJfZ2V0U2VjdGlvbkluZGV4IiwiSGFuZGxlIiwibm9uQ29sbGFwc2VkU2VjdGlvbkNvdW50IiwicmVkdWNlIiwiY29sbGFwc2VkIiwibmV3SGVpZ2h0IiwiY3VyckhlaWdodCIsInN1bSIsIm9mZnNldCIsIm1hcCIsIl8iLCJfYXBwbHlPdmVyZmxvdyIsIl9hcHBseUhlaWdodHMiLCJfY29tbWl0SGVpZ2h0cyIsImZpbmRJbmRleCIsInMiLCJfc2VjdGlvbkhlaWdodCIsIm1heEl0ZW1zIiwib3ZlcmZsb3ciLCJibGVuZCIsInVuY2xhbXBlZFNlY3Rpb25zIiwib3ZlcmZsb3dQZXJTZWN0aW9uIiwicHVzaCIsImFicyIsIl9yZWJhbGFuY2VBYm92ZSIsInNlY3Rpb25JbmRleCIsIm92ZXJmbG93QWJvdmUiLCJfcmViYWxhbmNlQmVsb3ciLCJvdmVyZmxvd0JlbG93IiwiX3JlbGF5b3V0IiwiY29uc3RyYWluZWQiLCJtYXhIZWlnaHQiLCJtaW5IZWlnaHQiLCJ1bmRlZmluZWQiLCJfc2V0VW5jb21taXR0ZWRTZWN0aW9uSGVpZ2h0Iiwic2lnbiIsImxheW91dCIsIl9sYXlvdXQiLCJfc2VjdGlvbkluZGV4IiwiX2luaXRpYWxIZWlnaHQiLCJEaXN0cmlidXRvciIsIkZpeGVkRGlzdHJpYnV0b3IiLCJpdGVtIiwiY2ZnIiwiX2hhbmRsZSIsImdldExheW91dCIsInJlc2l6ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBZ0JBOztBQWhCQTs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLFNBQVNBLEtBQVQsQ0FBZUMsTUFBZixFQUF1QkMsR0FBdkIsRUFBNEJDLEdBQTVCLEVBQWlDO0FBQzdCLE1BQUlGLE1BQU0sR0FBR0UsR0FBYixFQUFrQixPQUFPQSxHQUFQO0FBQ2xCLE1BQUlGLE1BQU0sR0FBR0MsR0FBYixFQUFrQixPQUFPQSxHQUFQO0FBQ2xCLFNBQU9ELE1BQVA7QUFDSDs7QUFFTSxNQUFNRyxNQUFOLENBQWE7QUFDaEJDLEVBQUFBLFdBQVcsQ0FBQ0MsV0FBRCxFQUFjQyxZQUFkLEVBQTRCQyxjQUE1QixFQUE0Q0MsT0FBNUMsRUFBcUQ7QUFDNUQ7QUFDQSxTQUFLQyxZQUFMLEdBQW9CSixXQUFwQixDQUY0RCxDQUc1RDtBQUNBOztBQUNBLFNBQUtLLFNBQUwsR0FBaUIsRUFBakIsQ0FMNEQsQ0FNNUQ7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QW1COEMsTUFBbkI7QUFDSDs7QUE5UWU7Ozs7QUFpUnBCLE1BQU1QLE1BQU4sQ0FBYTtBQUNUckQsRUFBQUEsV0FBVyxDQUFDd0YsTUFBRCxFQUFTWCxZQUFULEVBQXVCakYsTUFBdkIsRUFBK0I7QUFDdEMsU0FBSzZGLE9BQUwsR0FBZUQsTUFBZjtBQUNBLFNBQUtFLGFBQUwsR0FBcUJiLFlBQXJCO0FBQ0EsU0FBS2MsY0FBTCxHQUFzQi9GLE1BQXRCO0FBQ0g7O0FBRUQ2QixFQUFBQSxTQUFTLENBQUM3QixNQUFELEVBQVM7QUFDZCxTQUFLNkYsT0FBTCxDQUFhSCw0QkFBYixDQUNJLEtBQUtJLGFBRFQsRUFFSTlGLE1BQU0sR0FBRyxLQUFLK0YsY0FGbEI7O0FBSUEsV0FBTyxJQUFQO0FBQ0g7O0FBRURqRSxFQUFBQSxNQUFNLEdBQUc7QUFDTCxTQUFLK0QsT0FBTCxDQUFheEIsY0FBYjs7QUFDQSxXQUFPLElBQVA7QUFDSDs7QUFsQlE7O0FBcUJOLE1BQU0yQixXQUFOLFNBQTBCQyxjQUExQixDQUEyQztBQUM5QzdGLEVBQUFBLFdBQVcsQ0FBQzhGLElBQUQsRUFBT0MsR0FBUCxFQUFZO0FBQ25CLFVBQU1ELElBQU47QUFDQSxTQUFLRSxPQUFMLEdBQWVELEdBQUcsQ0FBQ0UsU0FBSixHQUFnQnpFLFVBQWhCLENBQTJCc0UsSUFBSSxDQUFDdkUsRUFBaEMsQ0FBZjtBQUNIOztBQUVERyxFQUFBQSxNQUFNLEdBQUc7QUFDTCxTQUFLc0UsT0FBTCxDQUFhdEUsTUFBYjtBQUNIOztBQUVEd0UsRUFBQUEsTUFBTSxDQUFDdEcsTUFBRCxFQUFTO0FBQ1gsU0FBS29HLE9BQUwsQ0FBYXZFLFNBQWIsQ0FBdUI3QixNQUF2QjtBQUNIOztBQVo2QyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBGaXhlZERpc3RyaWJ1dG9yIGZyb20gXCIuL2ZpeGVkXCI7XG5cbmZ1bmN0aW9uIGNsYW1wKGhlaWdodCwgbWluLCBtYXgpIHtcbiAgICBpZiAoaGVpZ2h0ID4gbWF4KSByZXR1cm4gbWF4O1xuICAgIGlmIChoZWlnaHQgPCBtaW4pIHJldHVybiBtaW47XG4gICAgcmV0dXJuIGhlaWdodDtcbn1cblxuZXhwb3J0IGNsYXNzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoYXBwbHlIZWlnaHQsIGluaXRpYWxTaXplcywgY29sbGFwc2VkU3RhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gY2FsbGJhY2sgdG8gc2V0IGhlaWdodCBvZiBzZWN0aW9uXG4gICAgICAgIHRoaXMuX2FwcGx5SGVpZ2h0ID0gYXBwbHlIZWlnaHQ7XG4gICAgICAgIC8vIGxpc3Qgb2Yge2lkLCBjb3VudH0gb2JqZWN0cyxcbiAgICAgICAgLy8gZGV0ZXJtaW5lcyBzZWN0aW9ucyBhbmQgb3JkZXIgb2YgdGhlbVxuICAgICAgICB0aGlzLl9zZWN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBzdG9yZXMgY29sbGFwc2VkIGJ5IGlkXG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZFN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgY29sbGFwc2VkU3RhdGUpO1xuICAgICAgICAvLyB0b3RhbCBhdmFpbGFibGUgaGVpZ2h0IHRvIHRoZSBsYXlvdXRcbiAgICAgICAgLy8gKGluY2x1ZGluZyByZXNpemUgaGFuZGxlcywgLi4uKVxuICAgICAgICB0aGlzLl9hdmFpbGFibGVIZWlnaHQgPSAwO1xuICAgICAgICAvLyBoZWlnaHRzIHN0b3JlZCBieSBzZWN0aW9uIHNlY3Rpb24gaWRcbiAgICAgICAgdGhpcy5fc2VjdGlvbkhlaWdodHMgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0aWFsU2l6ZXMpO1xuICAgICAgICAvLyBpbi1wcm9ncmVzcyBoZWlnaHRzLCB3aGlsZSBkcmFnZ2luZy4gQ29tbWl0dGVkIG9uIG1vdXNlLXVwLlxuICAgICAgICB0aGlzLl9oZWlnaHRzID0gW107XG4gICAgICAgIC8vIHVzZSB3aGlsZSBtYW51YWxseSByZXNpemluZyB0byBjYW5jZWxcbiAgICAgICAgLy8gdGhlIHJlc2l6ZSBmb3IgYSBnaXZlbiBtb3VzZSBwb3NpdGlvblxuICAgICAgICAvLyB3aGVuIHRoZSBwcmV2aW91cyByZXNpemUgbWFkZSB0aGUgbGF5b3V0XG4gICAgICAgIC8vIGNvbnN0cmFpbmVkXG4gICAgICAgIHRoaXMuX2NsYW1wZWRPZmZzZXQgPSAwO1xuICAgICAgICAvLyB1c2VkIHdoaWxlIG1hbnVhbGx5IHJlc2l6aW5nLCB0byBjbGVhclxuICAgICAgICAvLyBfY2xhbXBlZE9mZnNldCB3aGVuIHRoZSBkaXJlY3Rpb24gb2YgcmVzaXppbmcgY2hhbmdlc1xuICAgICAgICB0aGlzLl9sYXN0T2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLl9hbGxvd1doaXRlc3BhY2UgPSBvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dXaGl0ZXNwYWNlO1xuICAgICAgICB0aGlzLl9oYW5kbGVIZWlnaHQgPSAob3B0aW9ucyAmJiBvcHRpb25zLmhhbmRsZUhlaWdodCkgfHwgMDtcbiAgICB9XG5cbiAgICBzZXRBdmFpbGFibGVIZWlnaHQobmV3U2l6ZSkge1xuICAgICAgICB0aGlzLl9hdmFpbGFibGVIZWlnaHQgPSBuZXdTaXplO1xuICAgICAgICAvLyBuZWVkcyBtb3JlIHdvcmtcbiAgICAgICAgdGhpcy5fYXBwbHlOZXdTaXplKCk7XG4gICAgfVxuXG4gICAgZXhwYW5kU2VjdGlvbihpZCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZFN0YXRlW2lkXSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hcHBseU5ld1NpemUoKTtcbiAgICAgICAgdGhpcy5vcGVuSGFuZGxlKGlkKS5zZXRIZWlnaHQoaGVpZ2h0KS5maW5pc2goKTtcbiAgICB9XG5cbiAgICBjb2xsYXBzZVNlY3Rpb24oaWQpIHtcbiAgICAgICAgdGhpcy5fY29sbGFwc2VkU3RhdGVbaWRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYXBwbHlOZXdTaXplKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKHNlY3Rpb25zLCBhdmFpbGFibGVIZWlnaHQsIGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGhlaWdodENoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKGF2YWlsYWJsZUhlaWdodCkgJiYgYXZhaWxhYmxlSGVpZ2h0ICE9PSB0aGlzLl9hdmFpbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgIGhlaWdodENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYXZhaWxhYmxlSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VjdGlvbnNDaGFuZ2VkID1cbiAgICAgICAgICAgIHNlY3Rpb25zLmxlbmd0aCAhPT0gdGhpcy5fc2VjdGlvbnMubGVuZ3RoIHx8XG4gICAgICAgICAgICBzZWN0aW9ucy5zb21lKChhLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmlkICE9PSBiLmlkIHx8IGEuY291bnQgIT09IGIuY291bnQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhlaWdodENoYW5nZWQgJiYgIXNlY3Rpb25zQ2hhbmdlZCAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnM7XG4gICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGhpcy5fZ2V0QXZhaWxhYmxlSGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRIZWlnaHQgPSBNYXRoLmZsb29yKHRvdGFsSGVpZ2h0IC8gdGhpcy5fc2VjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fc2VjdGlvbnMuZm9yRWFjaCgoc2VjdGlvbiwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zZWN0aW9uSGVpZ2h0c1tzZWN0aW9uLmlkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlY3Rpb25IZWlnaHRzW3NlY3Rpb24uaWRdID0gY2xhbXAoXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldE1pbkhlaWdodChpKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0TWF4SGVpZ2h0KGkpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hcHBseU5ld1NpemUoKTtcbiAgICB9XG5cbiAgICBvcGVuSGFuZGxlKGlkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0U2VjdGlvbkluZGV4KGlkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIYW5kbGUodGhpcywgaW5kZXgsIHRoaXMuX3NlY3Rpb25IZWlnaHRzW2lkXSk7XG4gICAgfVxuXG4gICAgX2dldEF2YWlsYWJsZUhlaWdodCgpIHtcbiAgICAgICAgY29uc3Qgbm9uQ29sbGFwc2VkU2VjdGlvbkNvdW50ID0gdGhpcy5fc2VjdGlvbnMucmVkdWNlKChjb3VudCwgc2VjdGlvbikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29sbGFwc2VkID0gdGhpcy5fY29sbGFwc2VkU3RhdGVbc2VjdGlvbi5pZF07XG4gICAgICAgICAgICByZXR1cm4gY291bnQgKyAoY29sbGFwc2VkID8gMCA6IDEpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F2YWlsYWJsZUhlaWdodCAtICgobm9uQ29sbGFwc2VkU2VjdGlvbkNvdW50IC0gMSkgKiB0aGlzLl9oYW5kbGVIZWlnaHQpO1xuICAgIH1cblxuICAgIF9hcHBseU5ld1NpemUoKSB7XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuX2dldEF2YWlsYWJsZUhlaWdodCgpO1xuICAgICAgICBjb25zdCBjdXJySGVpZ2h0ID0gdGhpcy5fc2VjdGlvbnMucmVkdWNlKChzdW0sIHNlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzdW0gKyB0aGlzLl9zZWN0aW9uSGVpZ2h0c1tzZWN0aW9uLmlkXTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG5ld0hlaWdodCAtIGN1cnJIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodHMgPSB0aGlzLl9zZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+IHRoaXMuX3NlY3Rpb25IZWlnaHRzW3NlY3Rpb24uaWRdKTtcbiAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSB0aGlzLl9zZWN0aW9ucy5tYXAoKF8sIGkpID0+IGkpO1xuICAgICAgICB0aGlzLl9hcHBseU92ZXJmbG93KC1vZmZzZXQsIHNlY3Rpb25zLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fYXBwbHlIZWlnaHRzKCk7XG4gICAgICAgIHRoaXMuX2NvbW1pdEhlaWdodHMoKTtcbiAgICB9XG5cbiAgICBfZ2V0U2VjdGlvbkluZGV4KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5maW5kSW5kZXgoKHMpID0+IHMuaWQgPT09IGlkKTtcbiAgICB9XG5cbiAgICBfZ2V0TWF4SGVpZ2h0KGkpIHtcbiAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICBjb25zdCBjb2xsYXBzZWQgPSB0aGlzLl9jb2xsYXBzZWRTdGF0ZVtzZWN0aW9uLmlkXTtcblxuICAgICAgICBpZiAoY29sbGFwc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbkhlaWdodCgwKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VjdGlvbkhlaWdodChzZWN0aW9uLmNvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxMDAwMDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2VjdGlvbkhlaWdodChjb3VudCkge1xuICAgICAgICByZXR1cm4gMzYgKyAoY291bnQgPT09IDAgPyAwIDogNCArIChjb3VudCAqIDM0KSk7XG4gICAgfVxuXG4gICAgX2dldE1pbkhlaWdodChpKSB7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgICAgY29uc3QgY29sbGFwc2VkID0gdGhpcy5fY29sbGFwc2VkU3RhdGVbc2VjdGlvbi5pZF07XG4gICAgICAgIGNvbnN0IG1heEl0ZW1zID0gY29sbGFwc2VkID8gMCA6IDE7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWN0aW9uSGVpZ2h0KE1hdGgubWluKHNlY3Rpb24uY291bnQsIG1heEl0ZW1zKSk7XG4gICAgfVxuXG4gICAgX2FwcGx5T3ZlcmZsb3cob3ZlcmZsb3csIHNlY3Rpb25zLCBibGVuZCkge1xuICAgICAgICAvLyB0YWtlIHRoZSBnaXZlbiBvdmVyZmxvdyBhbW91bnQsIGFuZCBhcHBsaWVzIGl0IHRvIHRoZSBnaXZlbiBzZWN0aW9ucy5cbiAgICAgICAgLy8gY2FsbHMgaXRzZWxmIHJlY3Vyc2l2ZWx5IHVudGlsIGl0IGhhcyBkaXN0cmlidXRlZCBhbGwgdGhlIG92ZXJmbG93XG4gICAgICAgIC8vIG9yIHJ1biBvdXQgb2YgdW5jbGFtcGVkIHNlY3Rpb25zLlxuXG4gICAgICAgIGNvbnN0IHVuY2xhbXBlZFNlY3Rpb25zID0gW107XG5cbiAgICAgICAgbGV0IG92ZXJmbG93UGVyU2VjdGlvbiA9IGJsZW5kID8gKG92ZXJmbG93IC8gc2VjdGlvbnMubGVuZ3RoKSA6IG92ZXJmbG93O1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IGNsYW1wKFxuICAgICAgICAgICAgICAgIHRoaXMuX2hlaWdodHNbaV0gLSBvdmVyZmxvd1BlclNlY3Rpb24sXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0TWluSGVpZ2h0KGkpLFxuICAgICAgICAgICAgICAgIHRoaXMuX2dldE1heEhlaWdodChpKSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0ID09IHRoaXMuX2hlaWdodHNbaV0gLSBvdmVyZmxvd1BlclNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB1bmNsYW1wZWRTZWN0aW9ucy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd2hlbiBzZWN0aW9uIGlzIGdyb3dpbmcsIG92ZXJmbG93IGluY3JlYXNlcz9cbiAgICAgICAgICAgIC8vIDEwMCAtPSAyMDAgLSAzMDBcbiAgICAgICAgICAgIC8vIDEwMCAtPSAtMTAwXG4gICAgICAgICAgICAvLyAyMDBcbiAgICAgICAgICAgIG92ZXJmbG93IC09IHRoaXMuX2hlaWdodHNbaV0gLSBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHRzW2ldID0gbmV3SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKCFibGVuZCkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93UGVyU2VjdGlvbiA9IG92ZXJmbG93O1xuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVyZmxvdykgPCAxLjApIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJmbG93KSA+IDEuMCAmJiB1bmNsYW1wZWRTZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyB3ZSB3ZXJlbid0IGFibGUgdG8gZGlzdHJpYnV0ZSBhbGwgdGhlIG92ZXJmbG93IHNvIHJlY3Vyc2UgYW5kIHRyeSBhZ2FpblxuICAgICAgICAgICAgb3ZlcmZsb3cgPSB0aGlzLl9hcHBseU92ZXJmbG93KG92ZXJmbG93LCB1bmNsYW1wZWRTZWN0aW9ucywgYmxlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG92ZXJmbG93O1xuICAgIH1cblxuICAgIF9yZWJhbGFuY2VBYm92ZShzZWN0aW9uSW5kZXgsIG92ZXJmbG93QWJvdmUpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJmbG93QWJvdmUpID4gMS4wKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNlY3Rpb25JbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG92ZXJmbG93QWJvdmUgPSB0aGlzLl9hcHBseU92ZXJmbG93KG92ZXJmbG93QWJvdmUsIHNlY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3ZlcmZsb3dBYm92ZTtcbiAgICB9XG5cbiAgICBfcmViYWxhbmNlQmVsb3coc2VjdGlvbkluZGV4LCBvdmVyZmxvd0JlbG93KSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhvdmVyZmxvd0JlbG93KSA+IDEuMCkge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzZWN0aW9uSW5kZXggKyAxOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWN0aW9ucy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmZsb3dCZWxvdyA9IHRoaXMuX2FwcGx5T3ZlcmZsb3cob3ZlcmZsb3dCZWxvdywgc2VjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdmVyZmxvd0JlbG93O1xuICAgIH1cblxuICAgIC8vIEBwYXJhbSBvZmZzZXQgdGhlIGFtb3VudCB0aGUgc2VjdGlvbkluZGV4IGlzIG1vdmVkIGZyb20gd2hhdCBpcyBzdG9yZWQgaW4gX3NlY3Rpb25IZWlnaHRzLCBwb3NpdGl2ZSBpZiBkb3dud2FyZHNcbiAgICAvLyBpZiB3ZSdyZSBjb25zdHJhaW5lZCwgcmV0dXJuIHRoZSBvZmZzZXQgd2Ugc2hvdWxkIGJlIGNvbnN0cmFpbmVkIGF0LlxuICAgIF9yZWxheW91dChzZWN0aW9uSW5kZXggPSAwLCBvZmZzZXQgPSAwLCBjb25zdHJhaW5lZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2hlaWdodHMgPSB0aGlzLl9zZWN0aW9ucy5tYXAoKHNlY3Rpb24pID0+IHRoaXMuX3NlY3Rpb25IZWlnaHRzW3NlY3Rpb24uaWRdKTtcbiAgICAgICAgLy8gYXJlIHRoZXNlIHRoZSBhbW91bnRzIHRoZSBpdGVtcyBhYm92ZS9iZWxvdyBzaHJhbmsvZ3JldyBhbmQgbmVlZCB0byBiZSByZWxheW91dGVkP1xuICAgICAgICBsZXQgb3ZlcmZsb3dBYm92ZTtcbiAgICAgICAgbGV0IG92ZXJmbG93QmVsb3c7XG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuX2dldE1heEhlaWdodChzZWN0aW9uSW5kZXgpO1xuICAgICAgICBjb25zdCBtaW5IZWlnaHQgPSB0aGlzLl9nZXRNaW5IZWlnaHQoc2VjdGlvbkluZGV4KTtcbiAgICAgICAgLy8gbmV3IGhlaWdodCA+IG1heCA/XG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHRzW3NlY3Rpb25JbmRleF0gKyBvZmZzZXQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHB1bGxpbmcgZG93bndhcmRzIGFuZCBjb25zdHJhaW5lZFxuICAgICAgICAgICAgLy8gb3ZlcmZsb3dBYm92ZSA9IG1pbnVzIGhvdyBtdWNoIGFyZSB3ZSBhYm92ZSBtYXggaGVpZ2h0XG4gICAgICAgICAgICBvdmVyZmxvd0Fib3ZlID0gKG1heEhlaWdodCAtIHRoaXMuX2hlaWdodHNbc2VjdGlvbkluZGV4XSkgLSBvZmZzZXQ7XG4gICAgICAgICAgICBvdmVyZmxvd0JlbG93ID0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2hlaWdodHNbc2VjdGlvbkluZGV4XSArIG9mZnNldCA8IG1pbkhlaWdodCkgeyAvLyBuZXcgaGVpZ2h0IDwgbWluP1xuICAgICAgICAgICAgLy8gd2UncmUgcHVsbGluZyB1cHdhcmRzIGFuZCBjb25zdHJhaW5lZFxuICAgICAgICAgICAgb3ZlcmZsb3dBYm92ZSA9IChtaW5IZWlnaHQgLSB0aGlzLl9oZWlnaHRzW3NlY3Rpb25JbmRleF0pIC0gb2Zmc2V0O1xuICAgICAgICAgICAgb3ZlcmZsb3dCZWxvdyA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJmbG93QWJvdmUgPSAwO1xuICAgICAgICAgICAgb3ZlcmZsb3dCZWxvdyA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWlnaHRzW3NlY3Rpb25JbmRleF0gPSBjbGFtcCh0aGlzLl9oZWlnaHRzW3NlY3Rpb25JbmRleF0gKyBvZmZzZXQsIG1pbkhlaWdodCwgbWF4SGVpZ2h0KTtcblxuICAgICAgICAvLyB0aGVzZSBhcmUgcmVhc3NpZ25lZCB0aGUgYW1vdW50IG9mIG92ZXJmbG93IHRoYXQgY291bGQgbm90IGJlIHJlYmFsYW5jZWRcbiAgICAgICAgLy8gbWVhbmluZyB3ZSBkcmFnZ2VkIHRoZSBoYW5kbGUgdG9vIGZhciBhbmQgaXQgY2FuJ3QgZm9sbG93IHRoZSBjdXJzb3IgYW55bW9yZVxuICAgICAgICBvdmVyZmxvd0Fib3ZlID0gdGhpcy5fcmViYWxhbmNlQWJvdmUoc2VjdGlvbkluZGV4LCBvdmVyZmxvd0Fib3ZlKTtcbiAgICAgICAgb3ZlcmZsb3dCZWxvdyA9IHRoaXMuX3JlYmFsYW5jZUJlbG93KHNlY3Rpb25JbmRleCwgb3ZlcmZsb3dCZWxvdyk7XG5cbiAgICAgICAgaWYgKCFjb25zdHJhaW5lZCkgeyAvLyB0byBhdm9pZCByaXNrIG9mIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICAgICAgLy8gY2xhbXAgdG8gYXZvaWQgb3ZlcmZsb3dpbmcgb3IgdW5kZXJmbG93aW5nIHRoZSBwYWdlXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmZsb3dBYm92ZSkgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGRvIHRoZSBsYXlvdXQgYWdhaW4gd2l0aCBvZmZzZXQgLSB0aGUgYW1vdW50IG9mIHNwYWNlIHdlIHRvb2sgdG9vIG11Y2hcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxheW91dChzZWN0aW9uSW5kZXgsIG9mZnNldCArIG92ZXJmbG93QWJvdmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyBvdmVyZmxvd0Fib3ZlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmZsb3dCZWxvdykgPiAxLjApIHtcbiAgICAgICAgICAgICAgICAvLyBoZXJlIHdlIGRvIHRoZSBsYXlvdXQgYWdhaW4gd2l0aCBvZmZzZXQgLSB0aGUgYW1vdW50IG9mIHNwYWNlIHdlIHRvb2sgdG9vIG11Y2hcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxheW91dChzZWN0aW9uSW5kZXgsIG9mZnNldCAtIG92ZXJmbG93QmVsb3csIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgLSBvdmVyZmxvd0JlbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXBwbHlIZWlnaHRzKCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgX2FwcGx5SGVpZ2h0cygpIHtcbiAgICAgICAgLy8gYXBwbHkgdGhlIGhlaWdodHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlIZWlnaHQoc2VjdGlvbi5pZCwgdGhpcy5faGVpZ2h0c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY29tbWl0SGVpZ2h0cygpIHtcbiAgICAgICAgdGhpcy5fc2VjdGlvbnMuZm9yRWFjaCgoc2VjdGlvbiwgaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2VjdGlvbkhlaWdodHNbc2VjdGlvbi5pZF0gPSB0aGlzLl9oZWlnaHRzW2ldO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfc2V0VW5jb21taXR0ZWRTZWN0aW9uSGVpZ2h0KHNlY3Rpb25JbmRleCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChNYXRoLnNpZ24ob2Zmc2V0KSAhPSBNYXRoLnNpZ24odGhpcy5fbGFzdE9mZnNldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYW1wZWRPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NsYW1wZWRPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDAgJiYgb2Zmc2V0IDwgdGhpcy5fY2xhbXBlZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwICYmIG9mZnNldCA+IHRoaXMuX2NsYW1wZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xhbXBlZE9mZnNldCA9IHRoaXMuX3JlbGF5b3V0KHNlY3Rpb25JbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICB9XG59XG5cbmNsYXNzIEhhbmRsZSB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBzZWN0aW9uSW5kZXgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuX3NlY3Rpb25JbmRleCA9IHNlY3Rpb25JbmRleDtcbiAgICAgICAgdGhpcy5faW5pdGlhbEhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBzZXRIZWlnaHQoaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2xheW91dC5fc2V0VW5jb21taXR0ZWRTZWN0aW9uSGVpZ2h0KFxuICAgICAgICAgICAgdGhpcy5fc2VjdGlvbkluZGV4LFxuICAgICAgICAgICAgaGVpZ2h0IC0gdGhpcy5faW5pdGlhbEhlaWdodCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQuX2NvbW1pdEhlaWdodHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGlzdHJpYnV0b3IgZXh0ZW5kcyBGaXhlZERpc3RyaWJ1dG9yIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtLCBjZmcpIHtcbiAgICAgICAgc3VwZXIoaXRlbSk7XG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGNmZy5nZXRMYXlvdXQoKS5vcGVuSGFuZGxlKGl0ZW0uaWQpO1xuICAgIH1cblxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlLmZpbmlzaCgpO1xuICAgIH1cblxuICAgIHJlc2l6ZShoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlLnNldEhlaWdodChoZWlnaHQpO1xuICAgIH1cbn1cbiJdfQ==