"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _offset = _interopRequireDefault(require("./offset"));

/*
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class DocumentPosition {
  constructor(index, offset) {
    this._index = index;
    this._offset = offset;
  }

  get index() {
    return this._index;
  }

  get offset() {
    return this._offset;
  }

  compare(otherPos) {
    if (this._index === otherPos._index) {
      return this._offset - otherPos._offset;
    } else {
      return this._index - otherPos._index;
    }
  }

  iteratePartsBetween(other, model, callback) {
    if (this.index === -1 || other.index === -1) {
      return;
    }

    const [startPos, endPos] = this.compare(other) < 0 ? [this, other] : [other, this];

    if (startPos.index === endPos.index) {
      callback(model.parts[this.index], startPos.offset, endPos.offset);
    } else {
      const firstPart = model.parts[startPos.index];
      callback(firstPart, startPos.offset, firstPart.text.length);

      for (let i = startPos.index + 1; i < endPos.index; ++i) {
        const part = model.parts[i];
        callback(part, 0, part.text.length);
      }

      const lastPart = model.parts[endPos.index];
      callback(lastPart, 0, endPos.offset);
    }
  }

  forwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }

    let {
      index,
      offset
    } = this;
    const {
      parts
    } = model;

    while (index < parts.length) {
      const part = parts[index];

      while (offset < part.text.length) {
        if (!predicate(index, offset, part)) {
          return new DocumentPosition(index, offset);
        }

        offset += 1;
      } // end reached


      if (index === parts.length - 1) {
        return new DocumentPosition(index, offset);
      } else {
        index += 1;
        offset = 0;
      }
    }
  }

  backwardsWhile(model, predicate) {
    if (this.index === -1) {
      return this;
    }

    let {
      index,
      offset
    } = this;
    const parts = model.parts;

    while (index >= 0) {
      const part = parts[index];

      while (offset > 0) {
        if (!predicate(index, offset - 1, part)) {
          return new DocumentPosition(index, offset);
        }

        offset -= 1;
      } // start reached


      if (index === 0) {
        return new DocumentPosition(index, offset);
      } else {
        index -= 1;
        offset = parts[index].text.length;
      }
    }
  }

  asOffset(model) {
    if (this.index === -1) {
      return new _offset.default(0, true);
    }

    let offset = 0;

    for (let i = 0; i < this.index; ++i) {
      offset += model.parts[i].text.length;
    }

    offset += this.offset;
    const lastPart = model.parts[this.index];
    const atEnd = !lastPart || offset >= lastPart.text.length; // if no last part, we're at the end

    return new _offset.default(offset, atEnd);
  }

  isAtEnd(model) {
    if (model.parts.length === 0) {
      return true;
    }

    const lastPartIdx = model.parts.length - 1;
    const lastPart = model.parts[lastPartIdx];
    return this.index === lastPartIdx && this.offset === lastPart.text.length;
  }

  isAtStart() {
    return this.index === 0 && this.offset === 0;
  }

}

exports.default = DocumentPosition;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvcG9zaXRpb24uanMiXSwibmFtZXMiOlsiRG9jdW1lbnRQb3NpdGlvbiIsImNvbnN0cnVjdG9yIiwiaW5kZXgiLCJvZmZzZXQiLCJfaW5kZXgiLCJfb2Zmc2V0IiwiY29tcGFyZSIsIm90aGVyUG9zIiwiaXRlcmF0ZVBhcnRzQmV0d2VlbiIsIm90aGVyIiwibW9kZWwiLCJjYWxsYmFjayIsInN0YXJ0UG9zIiwiZW5kUG9zIiwicGFydHMiLCJmaXJzdFBhcnQiLCJ0ZXh0IiwibGVuZ3RoIiwiaSIsInBhcnQiLCJsYXN0UGFydCIsImZvcndhcmRzV2hpbGUiLCJwcmVkaWNhdGUiLCJiYWNrd2FyZHNXaGlsZSIsImFzT2Zmc2V0IiwiRG9jdW1lbnRPZmZzZXQiLCJhdEVuZCIsImlzQXRFbmQiLCJsYXN0UGFydElkeCIsImlzQXRTdGFydCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBZ0JBOztBQWhCQTs7Ozs7Ozs7Ozs7Ozs7O0FBa0JlLE1BQU1BLGdCQUFOLENBQXVCO0FBQ2xDQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsRUFBUUMsTUFBUixFQUFnQjtBQUN2QixTQUFLQyxNQUFMLEdBQWNGLEtBQWQ7QUFDQSxTQUFLRyxPQUFMLEdBQWVGLE1BQWY7QUFDSDs7QUFFRCxNQUFJRCxLQUFKLEdBQVk7QUFDUixXQUFPLEtBQUtFLE1BQVo7QUFDSDs7QUFFRCxNQUFJRCxNQUFKLEdBQWE7QUFDVCxXQUFPLEtBQUtFLE9BQVo7QUFDSDs7QUFFREMsRUFBQUEsT0FBTyxDQUFDQyxRQUFELEVBQVc7QUFDZCxRQUFJLEtBQUtILE1BQUwsS0FBZ0JHLFFBQVEsQ0FBQ0gsTUFBN0IsRUFBcUM7QUFDakMsYUFBTyxLQUFLQyxPQUFMLEdBQWVFLFFBQVEsQ0FBQ0YsT0FBL0I7QUFDSCxLQUZELE1BRU87QUFDSCxhQUFPLEtBQUtELE1BQUwsR0FBY0csUUFBUSxDQUFDSCxNQUE5QjtBQUNIO0FBQ0o7O0FBRURJLEVBQUFBLG1CQUFtQixDQUFDQyxL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QyxFQUFxQztBQUNqQ2YsTUFBQUEsTUFBTSxJQUFJTyxLQUFLLENBQUNJLEtBQU4sQ0FBWUksQ0FBWixFQUFlRixJQUFmLENBQW9CQyxNQUE5QjtBQUNIOztBQUNEZCxJQUFBQSxNQUFNLElBQUksS0FBS0EsTUFBZjtBQUNBLFVBQU1pQixRQUFRLEdBQUdWLEtBQUssQ0FBQ0ksS0FBTixDQUFZLEtBQUtaLEtBQWpCLENBQWpCO0FBQ0EsVUFBTXdCLEtBQUssR0FBRyxDQUFDTixRQUFELElBQWFqQixNQUFNLElBQUlpQixRQUFRLENBQUNKLElBQVQsQ0FBY0MsTUFBbkQsQ0FWWSxDQVUrQzs7QUFDM0QsV0FBTyxJQUFJUSxlQUFKLENBQW1CdEIsTUFBbkIsRUFBMkJ1QixLQUEzQixDQUFQO0FBQ0g7O0FBRURDLEVBQUFBLE9BQU8sQ0FBQ2pCLEtBQUQsRUFBUTtBQUNYLFFBQUlBLEtBQUssQ0FBQ0ksS0FBTixDQUFZRyxNQUFaLEtBQXVCLENBQTNCLEVBQThCO0FBQzFCLGFBQU8sSUFBUDtBQUNIOztBQUNELFVBQU1XLFdBQVcsR0FBR2xCLEtBQUssQ0FBQ0ksS0FBTixDQUFZRyxNQUFaLEdBQXFCLENBQXpDO0FBQ0EsVUFBTUcsUUFBUSxHQUFHVixLQUFLLENBQUNJLEtBQU4sQ0FBWWMsV0FBWixDQUFqQjtBQUNBLFdBQU8sS0FBSzFCLEtBQUwsS0FBZTBCLFdBQWYsSUFBOEIsS0FBS3pCLE1BQUwsS0FBZ0JpQixRQUFRLENBQUNKLElBQVQsQ0FBY0MsTUFBbkU7QUFDSDs7QUFFRFksRUFBQUEsU0FBUyxHQUFHO0FBQ1IsV0FBTyxLQUFLM0IsS0FBTCxLQUFlLENBQWYsSUFBb0IsS0FBS0MsTUFBTCxLQUFnQixDQUEzQztBQUNIOztBQXBIaUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgRG9jdW1lbnRPZmZzZXQgZnJvbSBcIi4vb2Zmc2V0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50UG9zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4O1xuICAgIH1cblxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuXG4gICAgY29tcGFyZShvdGhlclBvcykge1xuICAgICAgICBpZiAodGhpcy5faW5kZXggPT09IG90aGVyUG9zLl9pbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCAtIG90aGVyUG9zLl9vZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXggLSBvdGhlclBvcy5faW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpdGVyYXRlUGFydHNCZXR3ZWVuKG90aGVyLCBtb2RlbCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IC0xIHx8IG90aGVyLmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtzdGFydFBvcywgZW5kUG9zXSA9IHRoaXMuY29tcGFyZShvdGhlcikgPCAwID8gW3RoaXMsIG90aGVyXSA6IFtvdGhlciwgdGhpc107XG4gICAgICAgIGlmIChzdGFydFBvcy5pbmRleCA9PT0gZW5kUG9zLmluZGV4KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhtb2RlbC5wYXJ0c1t0aGlzLmluZGV4XSwgc3RhcnRQb3Mub2Zmc2V0LCBlbmRQb3Mub2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IG1vZGVsLnBhcnRzW3N0YXJ0UG9zLmluZGV4XTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZpcnN0UGFydCwgc3RhcnRQb3Mub2Zmc2V0LCBmaXJzdFBhcnQudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0UG9zLmluZGV4ICsgMTsgaSA8IGVuZFBvcy5pbmRleDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IG1vZGVsLnBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhcnQsIDAsIHBhcnQudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBtb2RlbC5wYXJ0c1tlbmRQb3MuaW5kZXhdO1xuICAgICAgICAgICAgY2FsbGJhY2sobGFzdFBhcnQsIDAsIGVuZFBvcy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yd2FyZHNXaGlsZShtb2RlbCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQge2luZGV4LCBvZmZzZXR9ID0gdGhpcztcbiAgICAgICAgY29uc3Qge3BhcnRzfSA9IG1vZGVsO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpbmRleF07XG4gICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFydC50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICghcHJlZGljYXRlKGluZGV4LCBvZmZzZXQsIHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRQb3NpdGlvbihpbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbmQgcmVhY2hlZFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAocGFydHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UG9zaXRpb24oaW5kZXgsIG9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJhY2t3YXJkc1doaWxlKG1vZGVsLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB7aW5kZXgsIG9mZnNldH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IG1vZGVsLnBhcnRzO1xuICAgICAgICB3aGlsZSAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGUoaW5kZXgsIG9mZnNldCAtIDEsIHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRG9jdW1lbnRQb3NpdGlvbihpbmRleCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdGFydCByZWFjaGVkXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50UG9zaXRpb24oaW5kZXgsIG9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4IC09IDE7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFydHNbaW5kZXhdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXNPZmZzZXQobW9kZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvY3VtZW50T2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5kZXg7ICsraSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IG1vZGVsLnBhcnRzW2ldLnRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSB0aGlzLm9mZnNldDtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBtb2RlbC5wYXJ0c1t0aGlzLmluZGV4XTtcbiAgICAgICAgY29uc3QgYXRFbmQgPSAhbGFzdFBhcnQgfHwgb2Zmc2V0ID49IGxhc3RQYXJ0LnRleHQubGVuZ3RoOyAvLyBpZiBubyBsYXN0IHBhcnQsIHdlJ3JlIGF0IHRoZSBlbmRcbiAgICAgICAgcmV0dXJuIG5ldyBEb2N1bWVudE9mZnNldChvZmZzZXQsIGF0RW5kKTtcbiAgICB9XG5cbiAgICBpc0F0RW5kKG1vZGVsKSB7XG4gICAgICAgIGlmIChtb2RlbC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3RQYXJ0SWR4ID0gbW9kZWwucGFydHMubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBtb2RlbC5wYXJ0c1tsYXN0UGFydElkeF07XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSBsYXN0UGFydElkeCAmJiB0aGlzLm9mZnNldCA9PT0gbGFzdFBhcnQudGV4dC5sZW5ndGg7XG4gICAgfVxuXG4gICAgaXNBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gMCAmJiB0aGlzLm9mZnNldCA9PT0gMDtcbiAgICB9XG59XG4iXX0=