"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setSelection = setSelection;
exports.setCaretPosition = setCaretPosition;
exports.getLineAndNodePosition = getLineAndNodePosition;

var _render = require("./render");

var _range = _interopRequireDefault(require("./range"));

/*
Copyright 2019 New Vector Ltd
Copyright 2019 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
function setSelection(editor, model, selection) {
  if (selection instanceof _range.default) {
    setDocumentRangeSelection(editor, model, selection);
  } else {
    setCaretPosition(editor, model, selection);
  }
}

function setDocumentRangeSelection(editor, model, range) {
  const sel = document.getSelection();
  sel.removeAllRanges();
  const selectionRange = document.createRange();
  const start = getNodeAndOffsetForPosition(editor, model, range.start);
  selectionRange.setStart(start.node, start.offset);
  const end = getNodeAndOffsetForPosition(editor, model, range.end);
  selectionRange.setEnd(end.node, end.offset);
  sel.addRange(selectionRange);
}

function setCaretPosition(editor, model, caretPosition) {
  const range = document.createRange();
  const {
    node,
    offset
  } = getNodeAndOffsetForPosition(editor, model, caretPosition);
  range.setStart(node, offset);
  range.collapse(true);
  const sel = document.getSelection();

  if (sel.rangeCount === 1) {
    const existingRange = sel.getRangeAt(0);

    if (existingRange.startContainer === range.startContainer && existingRange.startOffset === range.startOffset && existingRange.collapsed === range.collapsed) {
      // If the selection matches, it's important to leave it alone.
      // Recreating the selection state in at least Chrome can cause
      // strange side effects, like touch bar flickering on every key.
      // See https://github.com/vector-im/riot-web/issues/9299
      return;
    }
  }

  sel.removeAllRanges();
  sel.addRange(range);
}

function getNodeAndOffsetForPosition(editor, model, position) {
  const {
    offset,
    lineIndex,
    nodeIndex
  } = getLineAndNodePosition(model, position);
  const lineNode = editor.childNodes[lineIndex];
  let focusNode; // empty line with just a <br>

  if (nodeIndex === -1) {
    focusNode = lineNode;
  } else {
    focusNode = lineNode.childNodes[nodeIndex]; // make sure we have a text node

    if (focusNode.nodeType === Node.ELEMENT_NODE && focusNode.firstChild) {
      focusNode = focusNode.firstChild;
    }
  }

  return {
    node: focusNode,
    offset
  };
}

function getLineAndNodePosition(model, caretPosition) {
  const {
    parts
  } = model;
  const partIndex = caretPosition.index;
  const lineResult = findNodeInLineForPart(parts, partIndex);
  const {
    lineIndex
  } = lineResult;
  let {
    nodeIndex
  } = lineResult;
  let {
    offset
  } = caretPosition; // we're at an empty line between a newline part
  // and another newline part or end/start of parts.
  // set offset to 0 so it gets set to the <br> inside the line container

  if (nodeIndex === -1) {
    offset = 0;
  } else {
    // move caret out of uneditable part (into caret node, or empty line br) if needed
    ({
      nodeIndex,
      offset
    } = moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset));
  }

  return {
    lineIndex,
    nodeIndex,
    offset
  };
}

function findNodeInLineForPart(parts, partIndex) {
  let lineIndex = 0;
  let nodeIndex = -1;
  let prevPart = null; // go through to parts up till (and including) the index
  // to find newline parts

  for (let i = 0; i <= partIndex; ++i) {
    const part = parts[i];

    if (part.type === "newline") {
      lineIndex += 1;
      nodeIndex = -1;
      prevPart = null;
    } else {
      nodeIndex += 1;

      if ((0, _render.needsCaretNodeBefore)(part, prevPart)) {
        nodeIndex += 1;
      } // only jump over caret node if we're not at our destination node already,
      // as we'll assume in moveOutOfUneditablePart that nodeIndex
      // refers to the node  corresponding to the part,
      // and not an adjacent caret node


      if (i < partIndex) {
        const nextPart = parts[i + 1];
        const isLastOfLine = !nextPart || nextPart.type === "newline";

        if ((0, _render.needsCaretNodeAfter)(part, isLastOfLine)) {
          nodeIndex += 1;
        }
      }

      prevPart = part;
    }
  }

  return {
    lineIndex,
    nodeIndex
  };
}

function moveOutOfUneditablePart(parts, partIndex, nodeIndex, offset) {
  // move caret before or after uneditable part
  const part = parts[partIndex];

  if (part && !part.canEdit) {
    if (offset === 0) {
      nodeIndex -= 1;
      const prevPart = parts[partIndex - 1]; // if the previous node is a caret node, it's empty
      // so the offset can stay at 0
      // only when it's not, we need to set the offset
      // at the end of the node

      if (!(0, _render.needsCaretNodeBefore)(part, prevPart)) {
        offset = prevPart.text.length;
      }
    } else {
      nodeIndex += 1;
      offset = 0;
    }
  }

  return {
    nodeIndex,
    offset
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lZGl0b3IvY2FyZXQuanMiXSwibmFtZXMiOlsic2V0U2VsZWN0aW9uIiwiZWRpdG9yIiwibW9kZWwiLCJzZWxlY3Rpb24iLCJSYW5nZSIsInNldERvY3VtZW50UmFuZ2VTZWxlY3Rpb24iLCJzZXRDYXJldFBvc2l0aW9uIiwicmFuZ2UiLCJzZWwiLCJkb2N1bWVudCIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsInNlbGVjdGlvblJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzdGFydCIsImdldE5vZGVBbmRPZmZzZXRGb3JQb3NpdGlvbiIsInNldFN0YXJ0Iiwibm9kZSIsIm9mZnNldCIsImVuZCIsInNldEVuZCIsImFkZFJhbmdlIiwiY2FyZXRQb3NpdGlvbiIsImNvbGxhcHNlIiwicmFuZ2VDb3VudCIsImV4aXN0aW5nUmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImNvbGxhcHNlZCIsInBvc2l0aW9uIiwibGluZUluZGV4Iiwibm9kZUluZGV4IiwiZ2V0TGluZUFuZE5vZGVQb3NpdGlvbiIsImxpbmVOb2RlIiwiY2hpbGROb2RlcyIsImZvY3VzTm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImZpcnN0Q2hpbGQiLCJwYXJ0cyIsInBhcnRJbmRleCIsImluZGV4IiwibGluZVJlc3VsdCIsImZpbmROb2RlSW5MaW5lRm9yUGFydCIsIm1vdmVPdXRPZlVuZWRpdGFibGVQYXJ0IiwicHJldlBhcnQiLCJpIiwicGFydCIsInR5cGUiLCJuZXh0UGFydCIsImlzTGFzdE9mTGluZSIsImNhbkVkaXQiLCJ0ZXh0IiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWlCQTs7QUFDQTs7QUFsQkE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQk8sU0FBU0EsWUFBVCxDQUFzQkMsTUFBdEIsRUFBOEJDLEtBQTlCLEVBQXFDQyxTQUFyQyxFQUFnRDtBQUNuRCxNQUFJQSxT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OERkLE1BQTlELEVBQXNFO0FBQ2xFO0FBQ0EsUUFBTStCLElBQUksR0FBR1IsS0FBSyxDQUFDQyxTQUFELENBQWxCOztBQUNBLE1BQUlPLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUNJLE9BQWxCLEVBQTJCO0FBQ3ZCLFFBQUluQyxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNkYyxNQUFBQSxTQUFTLElBQUksQ0FBYjtBQUNBLFlBQU1lLFFBQVEsR0FBR04sS0FBSyxDQUFDQyxTQUFTLEdBQUcsQ0FBYixDQUF0QixDQUZjLENBR2Q7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDLGtDQUFxQk8sSUFBckIsRUFBMkJGLFFBQTNCLENBQUwsRUFBMkM7QUFDdkM3QixRQUFBQSxNQUFNLEdBQUc2QixRQUFRLENBQUNPLElBQVQsQ0FBY0MsTUFBdkI7QUFDSDtBQUNKLEtBVkQsTUFVTztBQUNIdkIsTUFBQUEsU0FBUyxJQUFJLENBQWI7QUFDQWQsTUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDSDtBQUNKOztBQUNELFNBQU87QUFBQ2MsSUFBQUEsU0FBRDtBQUFZZCxJQUFBQTtBQUFaLEdBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxOSBOZXcgVmVjdG9yIEx0ZFxuQ29weXJpZ2h0IDIwMTkgVGhlIE1hdHJpeC5vcmcgRm91bmRhdGlvbiBDLkkuQy5cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge25lZWRzQ2FyZXROb2RlQmVmb3JlLCBuZWVkc0NhcmV0Tm9kZUFmdGVyfSBmcm9tIFwiLi9yZW5kZXJcIjtcbmltcG9ydCBSYW5nZSBmcm9tIFwiLi9yYW5nZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGVkaXRvciwgbW9kZWwsIHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgICAgICBzZXREb2N1bWVudFJhbmdlU2VsZWN0aW9uKGVkaXRvciwgbW9kZWwsIHNlbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIG1vZGVsLCBzZWxlY3Rpb24pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0RG9jdW1lbnRSYW5nZVNlbGVjdGlvbihlZGl0b3IsIG1vZGVsLCByYW5nZSkge1xuICAgIGNvbnN0IHNlbCA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBnZXROb2RlQW5kT2Zmc2V0Rm9yUG9zaXRpb24oZWRpdG9yLCBtb2RlbCwgcmFuZ2Uuc3RhcnQpO1xuICAgIHNlbGVjdGlvblJhbmdlLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgY29uc3QgZW5kID0gZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uKGVkaXRvciwgbW9kZWwsIHJhbmdlLmVuZCk7XG4gICAgc2VsZWN0aW9uUmFuZ2Uuc2V0RW5kKGVuZC5ub2RlLCBlbmQub2Zmc2V0KTtcbiAgICBzZWwuYWRkUmFuZ2Uoc2VsZWN0aW9uUmFuZ2UpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlZGl0b3IsIG1vZGVsLCBjYXJldFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGNvbnN0IHtub2RlLCBvZmZzZXR9ID0gZ2V0Tm9kZUFuZE9mZnNldEZvclBvc2l0aW9uKGVkaXRvciwgbW9kZWwsIGNhcmV0UG9zaXRpb24pO1xuICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG5cbiAgICBjb25zdCBzZWwgPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsLnJhbmdlQ291bnQgPT09IDEpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSYW5nZSA9IHNlbC5nZXRSYW5nZUF0KDApO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBleGlzdGluZ1JhbmdlLnN0YXJ0Q29udGFpbmVyID09PSByYW5nZS5zdGFydENvbnRhaW5lciAmJlxuICAgICAgICAgICAgZXhpc3RpbmdSYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2Uuc3RhcnRPZmZzZXQgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nUmFuZ2UuY29sbGFwc2VkID09PSByYW5nZS5jb2xsYXBzZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIG1hdGNoZXMsIGl0J3MgaW1wb3J0YW50IHRvIGxlYXZlIGl0IGFsb25lLlxuICAgICAgICAgICAgLy8gUmVjcmVhdGluZyB0aGUgc2VsZWN0aW9uIHN0YXRlIGluIGF0IGxlYXN0IENocm9tZSBjYW4gY2F1c2VcbiAgICAgICAgICAgIC8vIHN0cmFuZ2Ugc2lkZSBlZmZlY3RzLCBsaWtlIHRvdWNoIGJhciBmbGlja2VyaW5nIG9uIGV2ZXJ5IGtleS5cbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVjdG9yLWltL3Jpb3Qtd2ViL2lzc3Vlcy85Mjk5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIHNlbC5hZGRSYW5nZShyYW5nZSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVBbmRPZmZzZXRGb3JQb3NpdGlvbihlZGl0b3IsIG1vZGVsLCBwb3NpdGlvbikge1xuICAgIGNvbnN0IHtvZmZzZXQsIGxpbmVJbmRleCwgbm9kZUluZGV4fSA9IGdldExpbmVBbmROb2RlUG9zaXRpb24obW9kZWwsIHBvc2l0aW9uKTtcbiAgICBjb25zdCBsaW5lTm9kZSA9IGVkaXRvci5jaGlsZE5vZGVzW2xpbmVJbmRleF07XG5cbiAgICBsZXQgZm9jdXNOb2RlO1xuICAgIC8vIGVtcHR5IGxpbmUgd2l0aCBqdXN0IGEgPGJyPlxuICAgIGlmIChub2RlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGZvY3VzTm9kZSA9IGxpbmVOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvY3VzTm9kZSA9IGxpbmVOb2RlLmNoaWxkTm9kZXNbbm9kZUluZGV4XTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKGZvY3VzTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZm9jdXNOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGZvY3VzTm9kZSA9IGZvY3VzTm9kZS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7bm9kZTogZm9jdXNOb2RlLCBvZmZzZXR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGluZUFuZE5vZGVQb3NpdGlvbihtb2RlbCwgY2FyZXRQb3NpdGlvbikge1xuICAgIGNvbnN0IHtwYXJ0c30gPSBtb2RlbDtcbiAgICBjb25zdCBwYXJ0SW5kZXggPSBjYXJldFBvc2l0aW9uLmluZGV4O1xuICAgIGNvbnN0IGxpbmVSZXN1bHQgPSBmaW5kTm9kZUluTGluZUZvclBhcnQocGFydHMsIHBhcnRJbmRleCk7XG4gICAgY29uc3Qge2xpbmVJbmRleH0gPSBsaW5lUmVzdWx0O1xuICAgIGxldCB7bm9kZUluZGV4fSA9IGxpbmVSZXN1bHQ7XG4gICAgbGV0IHtvZmZzZXR9ID0gY2FyZXRQb3NpdGlvbjtcbiAgICAvLyB3ZSdyZSBhdCBhbiBlbXB0eSBsaW5lIGJldHdlZW4gYSBuZXdsaW5lIHBhcnRcbiAgICAvLyBhbmQgYW5vdGhlciBuZXdsaW5lIHBhcnQgb3IgZW5kL3N0YXJ0IG9mIHBhcnRzLlxuICAgIC8vIHNldCBvZmZzZXQgdG8gMCBzbyBpdCBnZXRzIHNldCB0byB0aGUgPGJyPiBpbnNpZGUgdGhlIGxpbmUgY29udGFpbmVyXG4gICAgaWYgKG5vZGVJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBtb3ZlIGNhcmV0IG91dCBvZiB1bmVkaXRhYmxlIHBhcnQgKGludG8gY2FyZXQgbm9kZSwgb3IgZW1wdHkgbGluZSBicikgaWYgbmVlZGVkXG4gICAgICAgICh7bm9kZUluZGV4LCBvZmZzZXR9ID0gbW92ZU91dE9mVW5lZGl0YWJsZVBhcnQocGFydHMsIHBhcnRJbmRleCwgbm9kZUluZGV4LCBvZmZzZXQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtsaW5lSW5kZXgsIG5vZGVJbmRleCwgb2Zmc2V0fTtcbn1cblxuZnVuY3Rpb24gZmluZE5vZGVJbkxpbmVGb3JQYXJ0KHBhcnRzLCBwYXJ0SW5kZXgpIHtcbiAgICBsZXQgbGluZUluZGV4ID0gMDtcbiAgICBsZXQgbm9kZUluZGV4ID0gLTE7XG5cbiAgICBsZXQgcHJldlBhcnQgPSBudWxsO1xuICAgIC8vIGdvIHRocm91Z2ggdG8gcGFydHMgdXAgdGlsbCAoYW5kIGluY2x1ZGluZykgdGhlIGluZGV4XG4gICAgLy8gdG8gZmluZCBuZXdsaW5lIHBhcnRzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcGFydEluZGV4OyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcIm5ld2xpbmVcIikge1xuICAgICAgICAgICAgbGluZUluZGV4ICs9IDE7XG4gICAgICAgICAgICBub2RlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHByZXZQYXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKG5lZWRzQ2FyZXROb2RlQmVmb3JlKHBhcnQsIHByZXZQYXJ0KSkge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb25seSBqdW1wIG92ZXIgY2FyZXQgbm9kZSBpZiB3ZSdyZSBub3QgYXQgb3VyIGRlc3RpbmF0aW9uIG5vZGUgYWxyZWFkeSxcbiAgICAgICAgICAgIC8vIGFzIHdlJ2xsIGFzc3VtZSBpbiBtb3ZlT3V0T2ZVbmVkaXRhYmxlUGFydCB0aGF0IG5vZGVJbmRleFxuICAgICAgICAgICAgLy8gcmVmZXJzIHRvIHRoZSBub2RlICBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXJ0LFxuICAgICAgICAgICAgLy8gYW5kIG5vdCBhbiBhZGphY2VudCBjYXJldCBub2RlXG4gICAgICAgICAgICBpZiAoaSA8IHBhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdE9mTGluZSA9ICFuZXh0UGFydCB8fCBuZXh0UGFydC50eXBlID09PSBcIm5ld2xpbmVcIjtcbiAgICAgICAgICAgICAgICBpZiAobmVlZHNDYXJldE5vZGVBZnRlcihwYXJ0LCBpc0xhc3RPZkxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQYXJ0ID0gcGFydDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7bGluZUluZGV4LCBub2RlSW5kZXh9O1xufVxuXG5mdW5jdGlvbiBtb3ZlT3V0T2ZVbmVkaXRhYmxlUGFydChwYXJ0cywgcGFydEluZGV4LCBub2RlSW5kZXgsIG9mZnNldCkge1xuICAgIC8vIG1vdmUgY2FyZXQgYmVmb3JlIG9yIGFmdGVyIHVuZWRpdGFibGUgcGFydFxuICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgIGlmIChwYXJ0ICYmICFwYXJ0LmNhbkVkaXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgbm9kZUluZGV4IC09IDE7XG4gICAgICAgICAgICBjb25zdCBwcmV2UGFydCA9IHBhcnRzW3BhcnRJbmRleCAtIDFdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgYSBjYXJldCBub2RlLCBpdCdzIGVtcHR5XG4gICAgICAgICAgICAvLyBzbyB0aGUgb2Zmc2V0IGNhbiBzdGF5IGF0IDBcbiAgICAgICAgICAgIC8vIG9ubHkgd2hlbiBpdCdzIG5vdCwgd2UgbmVlZCB0byBzZXQgdGhlIG9mZnNldFxuICAgICAgICAgICAgLy8gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgaWYgKCFuZWVkc0NhcmV0Tm9kZUJlZm9yZShwYXJ0LCBwcmV2UGFydCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcmV2UGFydC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVJbmRleCArPSAxO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge25vZGVJbmRleCwgb2Zmc2V0fTtcbn1cbiJdfQ==