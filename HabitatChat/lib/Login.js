"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendLoginRequest = sendLoginRequest;
exports.default = void 0;

var _matrixJsSdk = _interopRequireDefault(require("matrix-js-sdk"));

/*
Copyright 2015, 2016 OpenMarket Ltd
Copyright 2017 Vector Creations Ltd
Copyright 2018 New Vector Ltd
Copyright 2019 Michael Telatynski <7t3chguy@gmail.com>
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
class Login {
  constructor(hsUrl, isUrl, fallbackHsUrl, opts) {
    this._hsUrl = hsUrl;
    this._isUrl = isUrl;
    this._fallbackHsUrl = fallbackHsUrl;
    this._currentFlowIndex = 0;
    this._flows = [];
    this._defaultDeviceDisplayName = opts.defaultDeviceDisplayName;
    this._tempClient = null; // memoize
  }

  getHomeserverUrl() {
    return this._hsUrl;
  }

  getIdentityServerUrl() {
    return this._isUrl;
  }

  setHomeserverUrl(hsUrl) {
    this._tempClient = null; // clear memoization

    this._hsUrl = hsUrl;
  }

  setIdentityServerUrl(isUrl) {
    this._tempClient = null; // clear memoization

    this._isUrl = isUrl;
  }
  /**
   * Get a temporary MatrixClient, which can be used for login or register
   * requests.
   * @returns {MatrixClient}
   */


  createTemporaryClient() {
    if (this._tempClient) return this._tempClient; // use memoization

    return this._tempClient = _matrixJsSdk.default.createClient({
      baseUrl: this._hsUrl,
      idBaseUrl: this._isUrl
    });
  }

  getFlows() {
    const self = this;
    const client = this.createTemporaryClient();
    return client.loginFlows().then(function (result) {
      self._flows = result.flows;
      self._currentFlowIndex = 0; // technically the UI should display options for all flows for the
      // user to then choose one, so return all the flows here.

      return self._flows;
    });
  }

  chooseFlow(flowIndex) {
    this._currentFlowIndex = flowIndex;
  }

  getCurrentFlowStep() {
    // technically the flow can have multiple steps, but no one does this
    // for login so we can ignore it.
    const flowStep = this._flows[this._currentFlowIndex];
    return flowStep ? flowStep.type : null;
  }

  loginViaPassword(username, phoneCountry, phoneNumber, pass) {
    const self = this;
    const isEmail = username.indexOf("@") > 0;
    let identifier;

    if (phoneCountry && phoneNumber) {
      identifier = {
        type: 'm.id.phone',
        country: phoneCountry,
        number: phoneNumber
      };
    } else if (isEmail) {
      identifier = {
        type: 'm.id.thirdparty',
        medium: 'email',
        address: username
      };
    } else {
      identifier = {
        type: 'm.id.user',
        user: username
      };
    }

    const loginParams = {
      password: pass,
      identifier: identifier,
      initial_device_display_name: this._defaultDeviceDisplayName
    };

    const tryFallbackHs = originalError => {
      return sendLoginRequest(self._fallbackHsUrl, this._isUrl, 'm.login.password', loginParams).catch(fallbackError => {
        console.log("fallback HS login failed", fallbackError); // throw the original error

        throw originalError;
      });
    };

    let originalLoginError = null;
    return sendLoginRequest(self._hsUrl, self._isUrl, 'm.login.password', loginParams).catch(error => {
      originalLoginError = error;

      if (error.httpStatus === 403) {
        if (self._fallbackHsUrl) {
          return tryFallbackHs(originalLoginError);
        }
      }

      throw originalLoginError;
    }).catch(error => {
      console.log("Login failed", error);
      throw error;
    });
  }

}
/**
 * Send a login request to the given server, and format the response
 * as a MatrixClientCreds
 *
 * @param {string} hsUrl   the base url of the Homeserver used to log in.
 * @param {string} isUrl   the base url of the default identity server
 * @param {string} loginType the type of login to do
 * @param {object} loginParams the parameters for the login
 *
 * @returns {MatrixClientCreds}
 */


exports.default = Login;

async function sendLoginRequest(hsUrl, isUrl, loginType, loginParams) {
  const client = _matrixJsSdk.default.createClient({
    baseUrl: hsUrl,
    idBaseUrl: isUrl
  });

  const data = await client.login(loginType, loginParams);
  const wellknown = data.well_known;

  if (wellknown) {
    if (wellknown["m.homeserver"] && wellknown["m.homeserver"]["base_url"]) {
      hsUrl = wellknown["m.homeserver"]["base_url"];
      console.log("Overrode homeserver setting with ".concat(hsUrl, " from login response"));
    }

    if (wellknown["m.identity_server"] && wellknown["m.identity_server"]["base_url"]) {
      // TODO: should we prompt here?
      isUrl = wellknown["m.identity_server"]["base_url"];
      console.log("Overrode IS setting with ".concat(isUrl, " from login response"));
    }
  }

  return {
    homeserverUrl: hsUrl,
    identityServerUrl: isUrl,
    userId: data.user_id,
    deviceId: data.device_id,
    accessToken: data.access_token
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Mb2dpbi5qcyJdLCJuYW1lcyI6WyJMb2dpbiIsImNvbnN0cnVjdG9yIiwiaHNVcmwiLCJpc1VybCIsImZhbGxiYWNrSHNVcmwiLCJvcHRzIiwiX2hzVXJsIiwiX2lzVXJsIiwiX2ZhbGxiYWNrSHNVcmwiLCJfY3VycmVudEZsb3dJbmRleCIsIl9mbG93cyIsIl9kZWZhdWx0RGV2aWNlRGlzcGxheU5hbWUiLCJkZWZhdWx0RGV2aWNlRGlzcGxheU5hbWUiLCJfdGVtcENsaWVudCIsImdldEhvbWVzZXJ2ZXJVcmwiLCJnZXRJZGVudGl0eVNlcnZlclVybCIsInNldEhvbWVzZXJ2ZXJVcmwiLCJzZXRJZGVudGl0eVNlcnZlclVybCIsImNyZWF0ZVRlbXBvcmFyeUNsaWVudCIsIk1hdHJpeCIsImNyZWF0ZUNsaWVudCIsImJhc2VVcmwiLCJpZEJhc2VVcmwiLCJnZXRGbG93cyIsInNlbGYiLCJjbGllbnQiLCJsb2dpbkZsb3dzIiwidGhlbiIsInJlc3VsdCIsImZsb3dzIiwiY2hvb3NlRmxvdyIsImZsb3dJbmRleCIsImdldEN1cnJlbnRGbG93U3RlcCIsImZsb3dTdGVwIiwidHlwZSIsImxvZ2luVmlhUGFzc3dvcmQiLCJ1c2VybmFtZSIsInBob25lQ291bnRyeSIsInBob25lTnVtYmVyIiwicGFzcyIsImlzRW1haWwiLCJpbmRleE9mIiwiaWRlbnRpZmllciIsImNvdW50cnkiLCJudW1iZXIiLCJtZWRpdW0iLCJhZGRyZXNzIiwidXNlciIsImxvZ2luUGFyYW1zIiwicGFzc3dvcmQiLCJpbml0aWFsX2RldmljZV9kaXNwbGF5X25hbWUiLCJ0cnlGYWxsYmFja0hzIiwib3JpZ2luYWxFcnJvciIsInNlbmRMb2dpblJlcXVlc3QiLCJjYXRjaCIsImZhbGxiYWNrRXJyb3IiLCJjb25zb2xlIiwibG9nIiwib3JpZ2luYWxMb2dpbkVycm9yIiwiZXJyb3IiLCJodHRwU3RhdHVzIiwibG9naW5UeXBlIiwiZGF0YSIsImxvZ2luIiwid2VsbGtub3duIiwid2VsbF9rbm93biIsImhvbWVzZXJ2ZXJVcmwiLCJpZGVudGl0eVNlcnZlclVybCIsInVzZXJJZCIsInVzZXJfaWQiLCJkZXZpY2VJZCIsImRldmljZV9pZCIsImFjY2Vzc1Rva2VuIiwiYWNjZXNzX3Rva2VuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0JBOztBQXBCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZSxNQUFNQSxLQUFOLENBQVk7QUFDdkJDLEVBQUFBLFdBQVcsQ0FBQ0MsS0FBRCxFQUFRQyxLQUFSLEVBQWVDLGFBQWYsRUFBOEJDLElBQTlCLEVBQW9DO0FBQzNDLFNBQUtDLE1BQUwsR0FBY0osS0FBZDtBQUNBLFNBQUtLLE1BQUwsR0FBY0osS0FBZDtBQUNBLFNBQUtLLGNBQUwsR0FBc0JKLGFBQXRCO0FBQ0EsU0FBS0ssaUJBQUwsR0FBeUIsQ0FBekI7QUFDQSxTQUFLQyxNQUFMLEdBQWMsRUFBZDtBQUNBLFNBQUtDLHlCQUFMLEdBQWlDTixJQUFJLENBQUNPLHdCQUF0QztBQUNBLFNBQUtDLFdBQUwsR0FBbUIsSUFBbkIsQ0FQMkMsQ0FPbEI7QUFDNUI7O0FBRURDLEVBQUFBLGdCQUFnQixHQUFHO0FBQ2YsV0FBTyxLQUFLUixNQUFaO0FBQ0g7O0FBRURTLEVBQUFBLG9CQUFvQixHQUFHO0FBQ25CLFdBQU8sS0FBS1IsTUFBWjtBQUNIOztBQUVEUyxFQUFBQSxnQkFBZ0IsQ0FBQ2QsS0FBRCxFQUFRO0FBQ3BCLFNBQUtXLFdBQUwsR0FBbUIsSUFBbkIsQ0FEb0IsQ0FDSzs7QUFDekIsU0FBS1AsTUFBTCxHQUFjSixLQUFkO0FBQ0g7O0FBRURlLEVBQUFBLG9CQUFvQixDQUFDZCxLQUFELEVBQVE7QUFDeEIsU0FBS1UsV0FBTCxHQUFtQixJQUFuQixDQUR3QixDQUNDOztBQUN6QixTQUFLTixNQUFMLEdBQWNKLEtBQWQ7QUFDSDtBQUVEOzs7Ozs7O0FBS0FlLEVBQUFBLHFCQUFxQixHQUFHO0FBQ3BCLFFBQUksS0FBS0wsV0FBVCxFQUFzQixPQUFPLEtBQUtBLFdBQVosQ0FERixD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VCxDQUErQixVQUEvQixDQUF0QyxFQUFrRjtBQUM5RTtBQUNBN0QsTUFBQUEsS0FBSyxHQUFHNkQsU0FBUyxDQUFDLG1CQUFELENBQVQsQ0FBK0IsVUFBL0IsQ0FBUjtBQUNBUixNQUFBQSxPQUFPLENBQUNDLEdBQVIsb0NBQXdDdEQsS0FBeEM7QUFDSDtBQUNKOztBQUVELFNBQU87QUFDSCtELElBQUFBLGFBQWEsRUFBRWhFLEtBRFo7QUFFSGlFLElBQUFBLGlCQUFpQixFQUFFaEUsS0FGaEI7QUFHSGlFLElBQUFBLE1BQU0sRUFBRU4sSUFBSSxDQUFDTyxPQUhWO0FBSUhDLElBQUFBLFFBQVEsRUFBRVIsSUFBSSxDQUFDUyxTQUpaO0FBS0hDLElBQUFBLFdBQVcsRUFBRVYsSUFBSSxDQUFDVztBQUxmLEdBQVA7QUFPSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5Db3B5cmlnaHQgMjAxNSwgMjAxNiBPcGVuTWFya2V0IEx0ZFxuQ29weXJpZ2h0IDIwMTcgVmVjdG9yIENyZWF0aW9ucyBMdGRcbkNvcHlyaWdodCAyMDE4IE5ldyBWZWN0b3IgTHRkXG5Db3B5cmlnaHQgMjAxOSBNaWNoYWVsIFRlbGF0eW5za2kgPDd0M2NoZ3V5QGdtYWlsLmNvbT5cbkNvcHlyaWdodCAyMDIwIFRoZSBNYXRyaXgub3JnIEZvdW5kYXRpb24gQy5JLkMuXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IE1hdHJpeCBmcm9tIFwibWF0cml4LWpzLXNka1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dpbiB7XG4gICAgY29uc3RydWN0b3IoaHNVcmwsIGlzVXJsLCBmYWxsYmFja0hzVXJsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuX2hzVXJsID0gaHNVcmw7XG4gICAgICAgIHRoaXMuX2lzVXJsID0gaXNVcmw7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrSHNVcmwgPSBmYWxsYmFja0hzVXJsO1xuICAgICAgICB0aGlzLl9jdXJyZW50Rmxvd0luZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fZmxvd3MgPSBbXTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdERldmljZURpc3BsYXlOYW1lID0gb3B0cy5kZWZhdWx0RGV2aWNlRGlzcGxheU5hbWU7XG4gICAgICAgIHRoaXMuX3RlbXBDbGllbnQgPSBudWxsOyAvLyBtZW1vaXplXG4gICAgfVxuXG4gICAgZ2V0SG9tZXNlcnZlclVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hzVXJsO1xuICAgIH1cblxuICAgIGdldElkZW50aXR5U2VydmVyVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVcmw7XG4gICAgfVxuXG4gICAgc2V0SG9tZXNlcnZlclVybChoc1VybCkge1xuICAgICAgICB0aGlzLl90ZW1wQ2xpZW50ID0gbnVsbDsgLy8gY2xlYXIgbWVtb2l6YXRpb25cbiAgICAgICAgdGhpcy5faHNVcmwgPSBoc1VybDtcbiAgICB9XG5cbiAgICBzZXRJZGVudGl0eVNlcnZlclVybChpc1VybCkge1xuICAgICAgICB0aGlzLl90ZW1wQ2xpZW50ID0gbnVsbDsgLy8gY2xlYXIgbWVtb2l6YXRpb25cbiAgICAgICAgdGhpcy5faXNVcmwgPSBpc1VybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0ZW1wb3JhcnkgTWF0cml4Q2xpZW50LCB3aGljaCBjYW4gYmUgdXNlZCBmb3IgbG9naW4gb3IgcmVnaXN0ZXJcbiAgICAgKiByZXF1ZXN0cy5cbiAgICAgKiBAcmV0dXJucyB7TWF0cml4Q2xpZW50fVxuICAgICAqL1xuICAgIGNyZWF0ZVRlbXBvcmFyeUNsaWVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBDbGllbnQpIHJldHVybiB0aGlzLl90ZW1wQ2xpZW50OyAvLyB1c2UgbWVtb2l6YXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBDbGllbnQgPSBNYXRyaXguY3JlYXRlQ2xpZW50KHtcbiAgICAgICAgICAgIGJhc2VVcmw6IHRoaXMuX2hzVXJsLFxuICAgICAgICAgICAgaWRCYXNlVXJsOiB0aGlzLl9pc1VybCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0Rmxvd3MoKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZVRlbXBvcmFyeUNsaWVudCgpO1xuICAgICAgICByZXR1cm4gY2xpZW50LmxvZ2luRmxvd3MoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgc2VsZi5fZmxvd3MgPSByZXN1bHQuZmxvd3M7XG4gICAgICAgICAgICBzZWxmLl9jdXJyZW50Rmxvd0luZGV4ID0gMDtcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IHRoZSBVSSBzaG91bGQgZGlzcGxheSBvcHRpb25zIGZvciBhbGwgZmxvd3MgZm9yIHRoZVxuICAgICAgICAgICAgLy8gdXNlciB0byB0aGVuIGNob29zZSBvbmUsIHNvIHJldHVybiBhbGwgdGhlIGZsb3dzIGhlcmUuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZmxvd3M7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNob29zZUZsb3coZmxvd0luZGV4KSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGbG93SW5kZXggPSBmbG93SW5kZXg7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudEZsb3dTdGVwKCkge1xuICAgICAgICAvLyB0ZWNobmljYWxseSB0aGUgZmxvdyBjYW4gaGF2ZSBtdWx0aXBsZSBzdGVwcywgYnV0IG5vIG9uZSBkb2VzIHRoaXNcbiAgICAgICAgLy8gZm9yIGxvZ2luIHNvIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgICAgIGNvbnN0IGZsb3dTdGVwID0gdGhpcy5fZmxvd3NbdGhpcy5fY3VycmVudEZsb3dJbmRleF07XG4gICAgICAgIHJldHVybiBmbG93U3RlcCA/IGZsb3dTdGVwLnR5cGUgOiBudWxsO1xuICAgIH1cblxuICAgIGxvZ2luVmlhUGFzc3dvcmQodXNlcm5hbWUsIHBob25lQ291bnRyeSwgcGhvbmVOdW1iZXIsIHBhc3MpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgY29uc3QgaXNFbWFpbCA9IHVzZXJuYW1lLmluZGV4T2YoXCJAXCIpID4gMDtcblxuICAgICAgICBsZXQgaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKHBob25lQ291bnRyeSAmJiBwaG9uZU51bWJlcikge1xuICAgICAgICAgICAgaWRlbnRpZmllciA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbS5pZC5waG9uZScsXG4gICAgICAgICAgICAgICAgY291bnRyeTogcGhvbmVDb3VudHJ5LFxuICAgICAgICAgICAgICAgIG51bWJlcjogcGhvbmVOdW1iZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzRW1haWwpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ20uaWQudGhpcmRwYXJ0eScsXG4gICAgICAgICAgICAgICAgbWVkaXVtOiAnZW1haWwnLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHVzZXJuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXIgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ20uaWQudXNlcicsXG4gICAgICAgICAgICAgICAgdXNlcjogdXNlcm5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9naW5QYXJhbXMgPSB7XG4gICAgICAgICAgICBwYXNzd29yZDogcGFzcyxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICBpbml0aWFsX2RldmljZV9kaXNwbGF5X25hbWU6IHRoaXMuX2RlZmF1bHREZXZpY2VEaXNwbGF5TmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0cnlGYWxsYmFja0hzID0gKG9yaWdpbmFsRXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzZW5kTG9naW5SZXF1ZXN0KFxuICAgICAgICAgICAgICAgIHNlbGYuX2ZhbGxiYWNrSHNVcmwsIHRoaXMuX2lzVXJsLCAnbS5sb2dpbi5wYXNzd29yZCcsIGxvZ2luUGFyYW1zLFxuICAgICAgICAgICAgKS5jYXRjaCgoZmFsbGJhY2tFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFsbGJhY2sgSFMgbG9naW4gZmFpbGVkXCIsIGZhbGxiYWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIHRocm93IHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgb3JpZ2luYWxMb2dpbkVycm9yID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHNlbmRMb2dpblJlcXVlc3QoXG4gICAgICAgICAgICBzZWxmLl9oc1VybCwgc2VsZi5faXNVcmwsICdtLmxvZ2luLnBhc3N3b3JkJywgbG9naW5QYXJhbXMsXG4gICAgICAgICkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBvcmlnaW5hbExvZ2luRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvci5odHRwU3RhdHVzID09PSA0MDMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fZmFsbGJhY2tIc1VybCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5RmFsbGJhY2tIcyhvcmlnaW5hbExvZ2luRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG9yaWdpbmFsTG9naW5FcnJvcjtcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvZ2luIGZhaWxlZFwiLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogU2VuZCBhIGxvZ2luIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHNlcnZlciwgYW5kIGZvcm1hdCB0aGUgcmVzcG9uc2VcbiAqIGFzIGEgTWF0cml4Q2xpZW50Q3JlZHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHNVcmwgICB0aGUgYmFzZSB1cmwgb2YgdGhlIEhvbWVzZXJ2ZXIgdXNlZCB0byBsb2cgaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNVcmwgICB0aGUgYmFzZSB1cmwgb2YgdGhlIGRlZmF1bHQgaWRlbnRpdHkgc2VydmVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9naW5UeXBlIHRoZSB0eXBlIG9mIGxvZ2luIHRvIGRvXG4gKiBAcGFyYW0ge29iamVjdH0gbG9naW5QYXJhbXMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsb2dpblxuICpcbiAqIEByZXR1cm5zIHtNYXRyaXhDbGllbnRDcmVkc31cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbmRMb2dpblJlcXVlc3QoaHNVcmwsIGlzVXJsLCBsb2dpblR5cGUsIGxvZ2luUGFyYW1zKSB7XG4gICAgY29uc3QgY2xpZW50ID0gTWF0cml4LmNyZWF0ZUNsaWVudCh7XG4gICAgICAgIGJhc2VVcmw6IGhzVXJsLFxuICAgICAgICBpZEJhc2VVcmw6IGlzVXJsLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5sb2dpbihsb2dpblR5cGUsIGxvZ2luUGFyYW1zKTtcblxuICAgIGNvbnN0IHdlbGxrbm93biA9IGRhdGEud2VsbF9rbm93bjtcbiAgICBpZiAod2VsbGtub3duKSB7XG4gICAgICAgIGlmICh3ZWxsa25vd25bXCJtLmhvbWVzZXJ2ZXJcIl0gJiYgd2VsbGtub3duW1wibS5ob21lc2VydmVyXCJdW1wiYmFzZV91cmxcIl0pIHtcbiAgICAgICAgICAgIGhzVXJsID0gd2VsbGtub3duW1wibS5ob21lc2VydmVyXCJdW1wiYmFzZV91cmxcIl07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgT3ZlcnJvZGUgaG9tZXNlcnZlciBzZXR0aW5nIHdpdGggJHtoc1VybH0gZnJvbSBsb2dpbiByZXNwb25zZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWxsa25vd25bXCJtLmlkZW50aXR5X3NlcnZlclwiXSAmJiB3ZWxsa25vd25bXCJtLmlkZW50aXR5X3NlcnZlclwiXVtcImJhc2VfdXJsXCJdKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgd2UgcHJvbXB0IGhlcmU/XG4gICAgICAgICAgICBpc1VybCA9IHdlbGxrbm93bltcIm0uaWRlbnRpdHlfc2VydmVyXCJdW1wiYmFzZV91cmxcIl07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgT3ZlcnJvZGUgSVMgc2V0dGluZyB3aXRoICR7aXNVcmx9IGZyb20gbG9naW4gcmVzcG9uc2VgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGhvbWVzZXJ2ZXJVcmw6IGhzVXJsLFxuICAgICAgICBpZGVudGl0eVNlcnZlclVybDogaXNVcmwsXG4gICAgICAgIHVzZXJJZDogZGF0YS51c2VyX2lkLFxuICAgICAgICBkZXZpY2VJZDogZGF0YS5kZXZpY2VfaWQsXG4gICAgICAgIGFjY2Vzc1Rva2VuOiBkYXRhLmFjY2Vzc190b2tlbixcbiAgICB9O1xufVxuIl19